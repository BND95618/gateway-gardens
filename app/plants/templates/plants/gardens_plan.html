<!-- app/plants/templates/gardens_plan.html -->
{% extends "plants/master.html" %}

{% block title %}
  <title>Garden | Plan</title>
{% endblock title %}

{% block css %}
<!-- Insert template css here -->
<style>
  a[href*='gardens_plan'] 
  {
    color:            white;
    background-color: slategray; 
  }
</style>
{% endblock css %}

{% block header-completion %}
  <!-- complete the header from master.html -->
  <header class="bnd-page-banner">
    <h3>My Garden Plan</h3>
  </header>
{% endblock header-completion %}

{% block content %}
    <div class="bnd-content-main-120">
        <!-- Canvas -->
        <canvas id="myCanvas">
            Your browser does not support HTML 5 Canvas
        </canvas>

        <!-- Canvas tools-->
        <form class = "bnd-light-grey">
            <div style="padding: 10px 0px 0px 10px">
                <label for="action" style="display: inline-block;">Action: </label>
                <select id="id_action" name="action">
                    <option value="select"   >select   </option>
                    <option value="add plant">add plant</option>
                    <option value="draw"     >draw     </option>
                    <option value="pan"      >pan      </option>
                    <option value="zoom"     >zoom     </option>
                </select>
                <span id="id_group_div" style="display: none;">
                    <button type="button" id="id_group" class="bnd-button bnd-padding-small bnd-grey bnd-round-medium">Group</button>
                </span>
                <span id="id_ungroup_div" style="display: none;">
                    <button type="button" id="id_ungroup" class="bnd-button bnd-padding-small bnd-grey bnd-round-medium">Ungroup</button>
                </span>
                <span class="bnd-right">
                    <button type="button" id="id_save"  class="bnd-button bnd-padding-small bnd-grey bnd-round-medium">Save</button>
                    <button type="button" id="id_clear" class="bnd-button bnd-padding-small bnd-grey bnd-round-medium">Clear</button>
                </span>
            </div>
        </form>

        <!-- Canvas tool options -->
        <form class = "bnd-light-grey bnd-text-black">
            <!-- Tool options -->
            <div style="margin: 0px; padding: 0px 0px 0px 10px">
                <div id="id_plant_div" style="display: none;">
                    <label for="plant" style="display: inline-block;">Plant: </label>
                    <select id="id_plant" name="plant">
                        <option value="--"> -- </option>
                        <optgroup label="Annual" class = "bnd-text-black">
                            {% for plant in plants %}
                                {% if plant.type_x == "Annual" %}
                                    <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                                {% endif %}
                            {% endfor %}
                        </optgroup>
                        <optgroup label="Fern">
                            {% for plant in plants %}
                                {% if plant.type_x == "Fern" %}
                                    <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                                {% endif %}
                            {% endfor %}
                        </optgroup>
                        <optgroup label="Grass">
                            {% for plant in plants %}
                                {% if plant.type_x == "Grass" %}
                                    <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                                {% endif %}
                            {% endfor %}
                        </optgroup>
                        <optgroup label="Groundcover">
                            {% for plant in plants %}
                                {% if plant.type_x == "Groundcover" %}
                                    <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                                {% endif %}
                            {% endfor %}
                        </optgroup>
                        <optgroup label="Perennial">
                            {% for plant in plants %}
                                {% if plant.type_x == "Perennial" %}
                                    <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                                {% endif %}
                            {% endfor %}
                        </optgroup>
                        <optgroup label="Shrub">
                            {% for plant in plants %}
                                {% if plant.type_x == "Shrub" %}
                                    <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                                {% endif %}
                            {% endfor %}
                        </optgroup>
                        <optgroup label="Succulent">
                            {% for plant in plants %}
                                {% if plant.type_x == "Succulent" %}
                                    <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                                {% endif %}
                            {% endfor %}
                        </optgroup>
                        <optgroup label="Succulent">
                            {% for plant in plants %}
                                {% if plant.type_x == "Succulent" %}
                                    <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                                {% endif %}
                            {% endfor %}
                        </optgroup>
                        <optgroup label="Tree-Deciduous">
                            {% for plant in plants %}
                                {% if plant.type_x == "Tree-Deciduous" %}
                                    <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                                {% endif %}
                            {% endfor %}
                        </optgroup>
                        <optgroup label="Tree-Evergreen">
                            {% for plant in plants %}
                                {% if plant.type_x == "Tree-Evergreen" %}
                                    <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                                {% endif %}
                            {% endfor %}
                        </optgroup>
                        <optgroup label="Vegetable">
                            {% for plant in plants %}
                                {% if plant.type_x == "Vegetable" %}
                                    <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                                {% endif %}
                            {% endfor %}
                        </optgroup>
                        <optgroup label="Vine">
                            {% for plant in plants %}
                                {% if plant.type_x == "Vine" %}
                                    <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                                {% endif %}
                            {% endfor %}
                        </optgroup>
                    </select>
                </div>
                
                <div id="id_shape_div" style="display: none;">
                    <label for="shape" style="display: inline-block;">Shape: </label>
                    <select id="id_shape" name="shape">
                        <option value="line"     >line     </option>
                        <option value="curve"    >curve    </option>
                        <option value="rectangle">rectangle</option>
                        <option value="circle"   >circle   </option>
                        <option value="ellipse"  >ellipse  </option>
                        <option value="polygon"  >polygon  </option>
                        <option value="free form">free form</option>
                    </select>
                </div>
                
                <div id="id_line_width_div" style="display: none;">
                    <label for="line_width" style="display: inline-block;">Line Width: </label>
                    <select id="id_line_width" name="line_width">
                        <option value="1">1 px</option>
                        <option value="2">2 px</option>
                        <option value="3">3 px</option>
                        <option value="4">4 px</option>
                    </select>
                </div>
            
                <div id="id_line_style_div" style="display: none;">
                    <label for="line_style" style="display: inline-block;">Line Style: </label>
                    <select id="id_line_style" name="line_style">
                        <option value="solid" >solid </option>
                        <option value="dashed">dashed</option>
                        <option value="dotted">dotted</option>
                    </select>
                </div>
        
                <div id="id_line_color_div" style="display: none;">
                    <label for="line_color" style="display: inline-block;">Line Color: </label>           
                    <input type="color" id="id_line_color" name="line_color" value="#000000"/>
                </div>

                <div id="id_line_opacity_sel_div" style="display: none;">
                    <label for="id_line_color_div" style="display: inline-block;">Line Opacity: </label>
                    <select id="id_line_opacity_sel" name="line_opacity_sel">
                        <option value=0.0>  0%</option>
                        <option value=0.1> 10%</option>
                        <option value=0.2> 20%</option>
                        <option value=0.3> 30%</option>
                        <option value=0.4> 40%</option>
                        <option value=0.5> 50%</option>
                        <option value=0.6> 60%</option>
                        <option value=0.7> 70%</option>
                        <option value=0.8> 80%</option>
                        <option value=0.9> 90%</option>
                        <option value=1.0 selected>100%</option>
                    </select>
                </div>
        
                <div id="id_fill_div" style="display: none;">
                    <label for="fill" style="display: inline-block;">Fill: </label>
                    <input type="checkbox" id="id_fill" name="fill">
                </div>

                <div id="id_fill_color_div" style="display: none;">
                    <label for="fill_color" style="display: inline-block;">Fill Color: </label>          
                    <input  type="color" id="id_fill_color" name="fill_color" value="#ffffff"/>
                </div>

                <div id="id_fill_opacity_sel_div" style="display: none;">
                    <label for="id_fill_color_div" style="display: inline-block;">Fill Opacity: </label>
                    <select id="id_fill_opacity_sel" name="fill_opacity_sel">
                        <option value=0.0>  0%</option>
                        <option value=0.1> 10%</option>
                        <option value=0.2> 20%</option>
                        <option value=0.3> 30%</option>
                        <option value=0.4> 40%</option>
                        <option value=0.5> 50%</option>
                        <option value=0.6> 60%</option>
                        <option value=0.7> 70%</option>
                        <option value=0.8> 80%</option>
                        <option value=0.9> 90%</option>
                        <option value=1.0 selected>100%</option>
                    </select>
                </div>

                <div id="id_opacity_slider_div" class="slidecontainer" style="display: none; margin: 10px">
                    <input type="range" id="id_opacity_slider" class="slider" min="0" max="100" value="50">
                    <output id="opacity" for="id_opacity_slider_div">100%</output>
                </div>
                
                <div id="id_zoom_select_div" style="display: none;">
                    <label for="zoom_select" style="display: inline-block;">Zoom: </label>
                    <select id="id_zoom_select" name="zoom_select">
                        <option value="Slider">Slider</option>
                        <option value="100%">100%</option>
                        <option value="200%">200%</option>
                        <option value="300%">300%</option>
                        <option value="400%">400%</option>
                        <option value="500%">500%</option>
                    </select>
                </div>

                <div id="id_zoom_slider_div" class="slidecontainer" style="display: none; margin: 10px">
                    <input type="range" id="id_zoom_slider" class="slider" min="100" max="500" value="250">
                    <output id="zoom" for="id_zoom_slider">100%</output>
                </div>
            </div>  

            <!-- Checkboxes to select layers to display -->
            <div style="margin: 0px; padding: 5px 0px 0px 10px">
                <div id="id_view_layer_div" style="display: inline">
                    <span>Display Layers:</span>
                
                    <input id= "view_layer_all" type="checkbox" name="view_layer" value="all" checked>
                    <label for="view_layer_all" style="display: inline-block;"> All</label>
                    
                    <input id ="view_layer_ground" type="checkbox" name="view_layer" value="ground">
                    <label for="view_layer_ground" style="display: inline-block;"> Ground</label>
                    
                    <input id ="view_layer_groundcover" type="checkbox" name="view_layer" value="groundcover">
                    <label for="view_layer_groundcover" style="display: inline-block;"> Groundcover</label>
                    
                    <input id ="view_layer_flower" type="checkbox" name="view_layer" value="flower">
                    <label for="view_layer_flower" style="display: inline-block;"> Flower</label>

                    <input id ="view_layer_shrub" type="checkbox" name="view_layer" value="shrub">
                    <label for="view_layer_shrub" style="display: inline-block;"> Shrub</label>

                    <input id ="view_layer_small_tree" type="checkbox" name="view_layer" value="small_tree">
                    <label for="view_layer_small_tree" style="display: inline-block;"> Small Tree</label>
                    
                    <input id ="view_layer_large_tree" type="checkbox" name="view_layer" value="large_tree">
                    <label for="view_layer_large_tree" style="display: inline-block;"> Large Tree</label>
                </div>
            </div>

            <!-- Radio buttons to select layer to draw on -->
            <div style="margin: 0px; padding: 0px 0px 0px 10px">
                <div id="id_draw_layer_div" style="display: none">
                    <span>Draw on Layer:</span>
                    
                    <input id ="draw_layer_ground" type="radio" name="draw_layer" value="ground" checked>
                    <label for="draw_layer_ground" style="display: inline-block;"> Ground</label>
                    
                    <input id ="draw_layer_groundcover" type="radio" name="draw_layer" value="groundcover">
                    <label for="draw_layer_groundcover" style="display: inline-block;"> Groundcover</label>
                    
                    <input id ="draw_layer_flower" type="radio" name="draw_layer" value="flower">
                    <label for="draw_layer_flower" style="display: inline-block;"> Flower</label>

                    <input id ="draw_layer_shrub" type="radio" name="draw_layer" value="shrub">
                    <label for="draw_layer_shrub" style="display: inline-block;"> Shrub</label>

                    <input id ="draw_layer_small_tree" type="radio" name="draw_layer" value="small_tree">
                    <label for="draw_layer_small_tree" style="display: inline-block;"> Small Tree</label>
                    
                    <input id ="draw_layer_large_tree" type="radio"  name="draw_layer" value="large_tree">
                    <label for="draw_layer_large_tree" style="display: inline-block;"> Large Tree</label>
                </div>
            </div>

            <!-- Display shape attributes below canvas -->
            <div style = "margin: 0px; padding: 5px 0px 0px 10px">
                <div id="id_shape_attributes">
                    <!-- shape attributes inserted here -->
                </div>
            </div>  
        </form>
        <!-------------------------------------------------------------------------->
        <!-- Modals                                                               -->
        <!-------------------------------------------------------------------------->
        <!-- Plant Details Modal -->
        <div id="plant_details_modal" class="bnd-modal">
            <p> Modal HTML to be Inserted Here! </p>
        </div>

        <!-- Shape Edit Modal -->
        <div id="planner_edit_modal" class="bnd-modal bnd-background-visible">
            <div class="bnd-modal-content-300">

                <header class="bnd-modal-header"> 
                    <!-- Close the shape edit modal -->
                    <span onclick="document.getElementById('planner_edit_modal').style.display='none'" 
                        class="bnd-button bnd-modal-close">&times;
                    </span>
                    <h3>Edit Shape</h2>
                </header>
                    
                <div>
                    <form id = "id_edit_form" name = "editForm" action = "">

                        <div class="line rectangle circle ellipse polygon">
                            <label for="labelForm" style="display: inline-block; width: 80px;">label: </label>
                            <input type="text" id="labelForm" name="labelForm" style="width: 120px;">
                            <br>
                        </div>

                        <div class="line curve">
                            <label for="xStartFtForm" style="display: inline-block; width: 80px;">X (start): </label>
                            <input type="number" id="xStartFtForm" name="xStartFtForm" style="width: 60px;">
                            <span>ft</span>
                            <input type="number" id="xStartInForm" name="xStartInForm" style="width: 60px;">
                            <span>in</span>
                            <br>

                            <label for="yStartFtForm" style="display: inline-block; width: 80px;">Y (start): </label>
                            <input type="number" id="yStartFtForm" name="yStartFtForm" style="width: 60px;">
                            <span>ft</span>
                            <input type="number" id="yStartInForm" name="yStartInForm" style="width: 60px;">
                            <span>in</span>
                            <br>
                        </div>

                        <div class="curve">
                            <label for="xControlFtForm" style="display: inline-block; width: 80px;">X (control): </label>
                            <input type="number" id="xControlFtForm" name="xControFtForm" style="width: 60px;">
                            <span>ft</span>
                            <input type="number" id="xControlInForm" name="xControlInForm" style="width: 60px;">
                            <span>in</span>
                            <br>

                            <label for="yControlFtForm" style="display: inline-block; width: 80px;">Y (control): </label>
                            <input type="number" id="yControlFtForm" name="yControlFtForm" style="width: 60px;">
                            <span>ft</span>
                            <input type="number" id="yControlInForm" name="yControlInForm" style="width: 60px;">
                            <span>in</span>
                            <br>
                        </div>

                        <div class="line curve">
                            <label for="xEndFtForm" style="display: inline-block; width: 80px;">X (end): </label>
                            <input type="number" id="xEndFtForm" name="xEndFtForm" style="width: 60px;">
                            <span>ft</span>
                            <input type="number" id="xEndInForm" name="xEndInForm" style="width: 60px;">
                            <span>in</span>
                            <br>

                            <label for="yEndFtForm" style="display: inline-block; width: 80px;">Y (end): </label>
                            <input type="number" id="yEndFtForm" name="yEndFtForm" style="width: 60px;">
                            <span>ft</span>
                            <input type="number" id="yEndInForm" name="yEndInForm" style="width: 60px;">
                            <span>in</span>
                            <br>
                        </div>

                        <div class="rectangle">
                            <label for="xFtForm" style="display: inline-block; width: 80px;">X: </label>
                            <input type="number" id="xFtForm" name="xFtForm" style="width: 60px;">
                            <span>ft</span>
                            <input type="number" id="xInForm" name="xInForm" style="width: 60px;">
                            <span>in</span>
                            <br>

                            <label for="yFtForm" style="display: inline-block; width: 80px;">Y: </label>
                            <input type="number" id="yFtForm" name="yFtForm" style="width: 60px;">
                            <span>ft</span>
                            <input type="number" id="yInForm" name="yInForm" style="width: 60px;">
                            <span>in</span>
                            <br>
                        </div>

                        <div class="circle ellipse">
                            <label for="xCenterFtForm" style="display: inline-block; width: 80px;">X (center): </label>
                            <input type="number" id="xCenterFtForm" name="xCenterFtForm" style="width: 60px;">
                            <span>ft</span>
                            <input type="number" id="xCenterInForm" name="xCenterInForm" style="width: 60px;">
                            <span>in</span>
                            <br>

                            <label for="yCenterFtForm" style="display: inline-block; width: 80px;">Y (center): </label>
                            <input type="number" id="yCenterFtForm" name="yCenterFtForm" style="width: 60px;">
                            <span>ft</span>
                            <input type="number" id="yCenterInForm" name="yCenterInForm" style="width: 60px;">
                            <span>in</span>
                            <br>
                        </div>

                        <div class="polygon" id="polygonHTML">
                            <p>Polygon vertices go here!</p>
                        </div>

                        <div class="rectangle">
                            <label for="widthFtForm" style="display: inline-block; width: 80px;">width: </label>
                            <input type="number" id="widthFtForm" name="widthFtForm" style="width: 60px;" min="0">
                            <span>ft</span>
                            <input type="number" id="widthInForm" name="widthInForm" style="width: 60px;" min="0">
                            <span>in</span>
                            <br>

                            <label for="heightFtForm" style="display: inline-block; width: 80px;">height: </label>
                            <input type="number" id="heightFtForm" name="heightFtForm" style="width: 60px;" min="0">
                            <span>ft</span>
                            <input type="number" id="heightInForm" name="heightInForm" style="width: 60px;" min="0">
                            <span>in</span>
                            <br>
                        </div>

                        <div class="circle">
                            <label for="radiusFtForm" style="display: inline-block; width: 80px;">radius: </label>
                            <input type="number" id="radiusFtForm" name="radiusFtForm" style="width: 60px;" min="0">
                            <span>ft</span>
                            <input type="number" id="radiusInForm" name="radiusInForm" style="width: 60px;" min="0">
                            <span>in</span>
                            <br>
                        </div>

                        <div class="ellipse">
                            <label for="xRadiusFtForm" style="display: inline-block; width: 80px;">X radius: </label>
                            <input type="number" id="xRadiusFtForm" name="xRadiusFtForm" style="width: 60px;" min="0">
                            <span>ft</span>
                            <input type="number" id="xRadiusInForm" name="xRadiusInForm" style="width: 60px;" min="0">
                            <span>in</span>
                            <br>

                            <label for="yRadiusFtForm" style="display: inline-block; width: 80px;">Y radius: </label>
                            <input type="number" id="yRadiusFtForm" name="yRadiusFtForm" style="width: 60px;" min="0">
                            <span>ft</span>
                            <input type="number" id="yRadiusInForm" name="yRadiusInForm" style="width: 60px;" min="0">
                            <span>in</span>
                            <br>
                        </div>

                        <div class="rectangle">
                            <label for="rotationForm" style="display: inline-block; width: 80px;">rotation: </label>
                            <input type="number" id="rotationForm" name="rotationForm" style="width: 60px;">
                            <span>degrees</span>
                            <br>
                        </div>

                        <div class="line curve rectangle circle ellipse polygon">
                            <label for="lineWidthForm" style="display: inline-block; width: 80px;">Line width:</label>
                            <input type="number" id="lineWidthForm" name="lineWidthForm" style="width: 60px;" min="1">
                            <span>pixels</span>
                            <br>

                            <label for="lineStyleForm" style="display: inline-block; width: 80px;">Line style:</label>
                            <select id="lineStyleForm" style="width: 60px;" name="lineStyleForm">
                                <option value="solid" >solid </option>
                                <option value="dashed">dashed</option>
                                <option value="dotted">dotted</option>
                            </select>
                            <br>

                            <label for="lineColorForm" style="display: inline-block; width: 80px;">Line color:</label>
                            <input type="color" id="lineColorForm" name="lineColorForm" style="width: 60px;">
                            <br>

                            <label for="lineOpacityForm" style="display: inline-block; width: 80px;">Opacity:</label>
                            <select id="lineOpacityForm" style="width: 60px;">
                                <option value=0.0>  0%</option>
                                <option value=0.1> 10%</option>
                                <option value=0.2> 20%</option>
                                <option value=0.3> 30%</option>
                                <option value=0.4> 40%</option>
                                <option value=0.5> 50%</option>
                                <option value=0.6> 60%</option>
                                <option value=0.7> 70%</option>
                                <option value=0.8> 80%</option>
                                <option value=0.9> 90%</option>
                                <option value=1.0>100%</option>
                            </select>
                            <br>
                        </div>

                        <div class="rectangle circle ellipse polygon">
                            <label for="fillColorForm" style="display: inline-block; width: 80px;">Fill color:</label>
                            <input type="color" id="fillColorForm" name="fillColorForm" style="width: 60px;">
                            <br>
                        
                            <label for="fillOpacityForm" style="display: inline-block; width: 80px;">Opacity:</label>
                            <select id="fillOpacityForm" style="width: 60px;">
                                <option value=0.0>  0%</option>
                                <option value=0.1> 10%</option>
                                <option value=0.2> 20%</option>
                                <option value=0.3> 30%</option>
                                <option value=0.4> 40%</option>
                                <option value=0.5> 50%</option>
                                <option value=0.6> 60%</option>
                                <option value=0.7> 70%</option>
                                <option value=0.8> 80%</option>
                                <option value=0.9> 90%</option>
                                <option value=1.0>100%</option>
                            </select>
                            <br>
                        </div>

                        <!-- on submit, process attribute value changes in Javascript -->
                        <input type="submit" value="Apply" class="bnd-button-submit">
                        <input type="reset"  value="Reset" class="bnd-button bnd-round-large bnd-grey">
                        <button type="button"              class="bnd-button-cancel"
                                onclick="document.getElementById('planner_edit_modal').style.display='none'">
                                Exit
                        </button>
                    </form>
                </div>
            </div>
        </div>

        <!-- Context menu - Plant -->
        <div id="ctxPlantMenu" class="ctxMenu">
            <div class = "ctxMenuItem">Plant: Show Details</div>
            <div class = "ctxMenuItem">Plant: Duplicate</div>
            <div class = "ctxMenuItem">Plant: Delete</div>
        </div>

        <!-- Context menu - Shape -->
        <div id="ctxShapeMenu" class="ctxMenu">
            <div class = "ctxMenuItem">Shape: Edit</div>
            <div class = "ctxMenuItem">Shape: Duplicate</div>
            <div class = "ctxMenuItem">Shape: Delete</div>
            <div class = "ctxMenuItem">Shape: To Front</div>
            <div class = "ctxMenuItem">Shape: To Back</div>
        </div>
        
    </div> 
{% endblock content %}

{% block js %}
<script>

    // Wait until the window has been fully loaded
    window.onload = canvasApp;

    function canvasApp()
    {
        // setup the canvas
        const canvas  = document.getElementById("myCanvas");
        const ctx     = canvas.getContext("2d");
        const ctxShapeMenu = document.getElementById('ctxShapeMenu');
        canvas.width  = window.innerWidth  -  40;
        canvas.height = window.innerHeight - 300;
        
        // setup global variables
        let action = "select";
        let xSelectRel,     ySelectRel;     // mouse selection coordinates - relative to viewport
        let xSelectRelSave, ySelectRelSave; // mouse selection coordinates - relative to viewport
        let xSelectAbs,     ySelectAbs;     // mouse selection coordinates - absolute
        let xSelectAbsSave, ySelectAbsSave; // mouse selection coordinates - absolute
        let xTransAbs,      yTransAbs;      // translated mouse selection coordinates
        let xMouse,         yMouse;         // current mouse position - relative to viewport
        let xMouseAbs,      yMouseAbs;      // current mouse position - absolute
        let xDelta,         yDelta;         // change in mouse position
        let xDeltaAcc = 0,  yDeltaAcc = 0;  //
        let nextShapeID = 0;                // 
        let nextPlantID = 0;                //
        let nextZIndex  = 0;                // current maximum z-index

        // Initilize global action flags
        let createShape    = false;
        let selectShape    = false;
        let resizeShape    = false; 
        let rotateShape    = false;
        let moveShape      = false;
        let moveGroup      = false;
        let panning        = false;
        let selectShapeCtx = false;
        let polygonWIP     = false; // actively drawing the polygon
        let polygonCurve   = false; // indicates whether or not the segment is a curve

        // setup global objects
        let activeShape  = null;
        let activeHandle = null;

        // Shape classes
        class Shape 
        {
            constructor(type, id, grouped, label, layer, zIndex,
                        lineWidth, lineStyle, lineColor, lineOpacity,
                        fill, fillColor, fillPattern, fillOpacity) 
            {
                this.type        = type;
                this.id          = id;
                this.grouped     = grouped;
                this.label       = label;
                this.layer       = layer;
                this.zIndex      = zIndex;
                this.lineWidth   = lineWidth;
                this.lineStyle   = lineStyle;
                this.lineColor   = lineColor;
                this.lineOpacity = lineOpacity;
                this.fill        = fill;
                this.fillColor   = fillColor;
                this.fillPattern = fillPattern;
                this.fillOpacity = fillOpacity;
            }
            editMenuClear()
            {
                // turn off display for all edit fields
                // required fields will be subsequently turned back on
                // AR: Change to a more efficient selector
                for (let i = 0; i < line.length; i++) 
                {
                    line[i].style.display = "none";
                }
                for (let i = 0; i < curve.length; i++) 
                {
                    curve[i].style.display = "none";
                }
                for (let i = 0; i < rectangle.length; i++) 
                {
                    rectangle[i].style.display = "none";
                }
                for (let i = 0; i < circle.length; i++) 
                {
                    circle[i].style.display = "none";
                }
                for (let i = 0; i < ellipse.length; i++) 
                {
                    ellipse[i].style.display = "none";
                }
                for (let i = 0; i < polygon.length; i++) 
                {
                    polygon[i].style.display = "none";
                }
            }
            placeHandle(location, x, y)
            {
                let handle = 
                { 
                    type       : "handle", 
                    x          : x, 
                    y          : y, 
                    radius     : 5,
                    startAngle : 0, 
                    endAngle   : 2 * Math.PI,
                    direction  : "clockwise",
                    lineWidth  : 1,
                    lineStyle  : "solid",
                    lineColor  : "black",
                    color      : "white",
                    location   : location,
                    rotation   : 0,
                    shape_id   : 0
                };
                return(handle);       
            }
            drawHandles(handles)
            {
                for(let i = 0; i < handles.length; i++)
                {
                    // setup the drawing parameters
                    ctx.lineWidth   = handles[i].lineWidth;
                    ctx.strokeStyle = handles[i].lineColor;
                    ctx.fillStyle   = handles[i].fillColor;
                    ctx.globalAlpha = 1.0;
                    ctx.setLineDash([])

                    // adjust the handle radius based upon he scale factor
                    const radiusScaled = handles[i].radius / viewportTransform.scale;

                    // find center of associated shape to determine the point of rotation for handle
                    let xShapeCenter = this.x + this.width  / 2;
                    let yShapeCenter = this.y + this.height / 2;
                    //
                    ctx.save();
                    // Translate to rectangle center
                    ctx.translate(xShapeCenter, yShapeCenter);
                    // Rotate
                    ctx.rotate(this.rotation);
                    // Translate back
                    ctx.translate(-xShapeCenter, -yShapeCenter);

                    // Draw the handle
                    ctx.beginPath();
                    ctx.arc(handles[i].x, handles[i].y, radiusScaled, handles[i].startAngle, handles[i].endAngle, handles[i].direction);
                    ctx.stroke();
                    //
                    ctx.restore();
                }      
            }
        }
        class Line      extends Shape 
        {
            constructor(type, id, grouped, label, layer, zIndex,
                        lineWidth, lineStyle, lineColor, lineOpacity,
                        fill, fillColor, fillPattern, fillOpacity,
                        xStart, yStart, xEnd, yEnd) 
            {
                super(type, id, grouped, label, layer, zIndex,
                      lineWidth, lineStyle, lineColor, lineOpacity,
                      fill, fillColor, fillPattern, fillOpacity);
                this.xStart  = xStart;
                this.yStart  = yStart;
                this.xEnd    = xEnd;
                this.yEnd    = yEnd;
                this.handles = [];
            }
            createShape(dx, dy)
            {
                this.xEnd += dx;
                this.yEnd += dy;
            }
            createShapeEnd()
            {
                if((this.xStart != this.xEnd) || (this.yStart != this.yEnd))
                {
                    this.label = prompt("Shape label:");
                    shapes.push(this);
                }
                else
                {
                    alert("Line not saved - zero length");
                }
                activeShape = null;
            }
            select(x, y) 
            {
                // Determine if the selection point is 'close' to the line

                // set the threshold
                const threshold = 3;
                        
                // Calculate the difference in coordinates for the line segment
                const dx = this.xEnd - this.xStart;
                const dy = this.yEnd - this.yStart;
    
                // Calculate the squared length of the line segment
                const lineLengthSq = dx * dx + dy * dy;
    
                // Calculate the parameter 't' for the closest point on the *infinite* line
                // This 't' represents the projection of the point onto the line.
                const t = ((x - this.xStart) * dx + (y - this.yStart) * dy) / lineLengthSq;
    
                // Clamp 't' to the range [0, 1] to ensure the closest point is on the *segment*
                const closestX = this.xStart + t * dx;
                const closestY = this.yStart + t * dy;
    
                // Calculate the distance from the point to the closest point on the segment
                const distance = Math.sqrt(Math.pow(x - closestX, 2) + Math.pow(y - closestY, 2));
    
                // If line is selected, draw handles
                if(!this.grouped && distance <= threshold)
                {
                    this.createHandles();
                }
                return(distance <= threshold);
            }
            createHandles()
            {
                this.handles = [];
                this.handles.push(this.placeHandle("start", this.xStart, this.yStart));
                this.handles.push(this.placeHandle("end",   this.xEnd,   this.yEnd));
            }
            selectHandle(x, y)
            {
                let handleSelected = false;
                for(let i = 0; i < this.handles.length; i++)
                {
                    let distance = Math.sqrt(Math.pow((x - this.handles[i].x), 2) + 
                                             Math.pow((y - this.handles[i].y), 2))
                    // Determine if one of the handles has been selected
                    if (distance <= this.handles[i].radius)
                    {
                        handleSelected = true;
                        return(this.handles[i])
                    }
                }
                return(null); 
            }
            clearHandles()
            {
                this.handles = [];
            }
            move(dx, dy)
            {
                this.xStart += dx;
                this.yStart += dy;
                this.xEnd   += dx;
                this.yEnd   += dy;
                // move the handles
                for(let i = 0; i < this.handles.length; i++)
                {
                    this.handles[i].x += dx;
                    this.handles[i].y += dy;
                }
            }
            resize(handle, dx, dy)
            {
                if (handle.location == "start")
                {
                    this.xStart += dx;
                    this.yStart += dy;

                    this.handles[0].x += dx;
                    this.handles[0].y += dy;
                }
                else if (handle.location == "end")
                {
                    this.xEnd += dx;
                    this.yEnd += dy;

                    this.handles[1].x += dx;
                    this.handles[1].y += dy;
                }   
            }
            editMenu()
            {
                super.editMenuClear();
                // turn on the display for all edit form fields used by line
                for (let i = 0; i < line.length; i++) 
                {
                    line[i].style.display = "inline";
                }
                // prepopulate the shape attribute fields - convert pixels to ft/in
                labelForm.value     = this.label;
                xStartFtForm.value  = Math.trunc(this.xStart / 12) - (extBorder / 12);
                xStartInForm.value  = this.xStart % 12;
                yStartFtForm.value  = Math.trunc(this.yStart / 12) - (extBorder / 12);
                yStartInForm.value  = this.yStart % 12;
                xEndFtForm.value    = Math.trunc(this.xEnd / 12) - (extBorder / 12);
                xEndInForm.value    = this.xEnd % 12;
                yEndFtForm.value    = Math.trunc(this.yEnd / 12) - (extBorder / 12);
                yEndInForm.value    = this.yEnd % 12;
                lineWidthForm.value = this.lineWidth;
                lineStyleForm.value = this.lineStyle;
                lineColorForm.value = this.lineColor;
            }
            editSave()
            {
                // update the line with the new attribute values - convert ft/in to pixels
                this.label     = labelForm.value;
                this.xStart    = (Number(xStartFtForm.value) * 12) + 
                                 (Number(xStartInForm.value) % 12) +
                                 extBorder;
                this.yStart    = (Number(yStartFtForm.value) * 12) + 
                                 (Number(yStartInForm.value) % 12) +
                                 extBorder;
                this.xEnd      = (Number(xEndFtForm.value) * 12) + 
                                 (Number(xEndInForm.value) % 12) +
                                 extBorder;
                this.yEnd      = (Number(yEndFtForm.value) * 12) + 
                                 (Number(yEndInForm.value) % 12) +
                                 extBorder;
                this.lineWidth = Number(lineWidthForm.value);
                this.lineStyle = lineStyleForm.value;
                this.lineColor = lineColorForm.value;
                // update the handles
                this.createHandles();
            }
            duplicate(id)
            {
                const newLine = new Line(
                    this.type,
                    id,
                    false,
                    this.label,
                    this.layer,
                    this.nextZIndex,
                    this.lineWidth,
                    this.lineStyle,
                    this.lineColor,
                    this.lineOpacity,
                    this.fill,
                    this.fillColor,
                    this.fillPattern,
                    this.fillOpacity,
                    this.xStart + 20,
                    this.yStart + 20,
                    this.xEnd + 20,
                    this.yEnd + 20,
                    []
                    );
                    return(newLine);
            }
            showAttributes()
            {
                let xStart = this.xStart - extBorder;
                let yStart = this.yStart - extBorder;
                let xEnd   = this.xEnd   - extBorder;
                let yEnd   = this.yEnd   - extBorder;

                let length = Math.round(Math.sqrt(Math.pow((this.xEnd - this.xStart), 2) + 
                                                  Math.pow((this.yEnd - this.yStart), 2)))
                let attributes = "<span>" + this.label + ": " +
                                 "start: (" + pix2ft(xStart) + ", " + pix2ft(yStart) + ") " +
                                 "end: ("   + pix2ft(xEnd)   + ", " + pix2ft(yEnd)   + ") " +
                                 "length: " + pix2ft(length) +
                                 "</span>";
                return(attributes);
            }
            draw()
            {
                // setup the drawing parameters
                ctx.lineWidth   = this.lineWidth;
                if(this.lineStyle == 'solid')
                {
                    ctx.setLineDash([]);
                }
                else if(this.lineStyle == 'dashed')
                {
                    ctx.setLineDash([7, 5]);
                }
                else if(this.lineStyle == 'dotted')
                {
                    ctx.setLineDash([2, 4]);
                }
                ctx.strokeStyle = this.lineColor;

                // draw the line
                ctx.beginPath();
                ctx.moveTo(this.xStart, this.yStart);
                ctx.lineTo(this.xEnd,   this.yEnd);
                ctx.globalAlpha = this.lineOpacity;
                ctx.stroke();

                // draw the label - find the center of the line
                const xShapeCenter = (this.xEnd + this.xStart) / 2;
                const yShapeCenter = (this.yEnd + this.yStart) / 2;
                const maxWidth = Math.sqrt((Math.pow((this.xEnd - this.xStart), 2)) + 
                                           (Math.pow((this.yEnd - this.yStart), 2))) * 0.8;

                ctx.font         = '16px chalkboard';
                ctx.fillStyle    = 'black';
                ctx.textAlign    = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.label, xShapeCenter, yShapeCenter, maxWidth);

                // draw the handles
                if(!this.grouped && this.handles.length > 0)
                {
                    super.drawHandles(this.handles);
                }
            }
            restore(shape_JSON)
            {
                this.type        = shape_JSON.type;
                this.id          = shape_JSON.id;
                this.grouped     = shape_JSON.grouped;
                this.label       = shape_JSON.label;
                this.layer       = shape_JSON.layer;
                this.zIndex      = shape_JSON.zIndex;
                this.lineColor   = shape_JSON.lineColor;
                this.lineStyle   = shape_JSON.lineStyle;
                this.lineWidth   = shape_JSON.lineWidth;
                this.lineOpacity = shape_JSON.lineOpacity;
                this.fill        = shape_JSON.fill;
                this.fillColor   = shape_JSON.fillColor;
                this.fillOpacity = shape_JSON.fillOpacity;
                this.xStart      = shape_JSON.xStart;
                this.yStart      = shape_JSON.yStart;
                this.xEnd        = shape_JSON.xEnd;
                this.yEnd        = shape_JSON.yEnd;
            }
        }
        class Curve     extends Shape
        {
            constructor(type, id, grouped, label, layer, zIndex,
                        lineWidth, lineStyle, lineColor, lineOpacity,
                        fill, fillColor, fillPattern, fillOpacity,
                        xStart, yStart, xControl, yControl, xEnd, yEnd) 
            {
                super(type, id, grouped, label, layer, zIndex,
                      lineWidth, lineStyle, lineColor, lineOpacity,
                      fill, fillColor, fillPattern, fillOpacity);
                this.xStart   = xStart;
                this.yStart   = yStart;
                this.xControl = xControl;
                this.yControl = yControl;
                this.xEnd     = xEnd;
                this.yEnd     = yEnd;
                this.handles  = [];
            }
            createShape(dx, dy)
            {
                this.xEnd += dx;
                this.yEnd += dy;

                // Simple control point calculation 
                // (e.g., halfway between start and end, slightly offset)
                this.xControl = (this.xStart + this.xEnd) / 2;
                // Pulls the curve upwards
                this.yControl = Math.min(this.yStart, this.yEnd) - 50;
            }
            createShapeEnd()
            {
                if((this.xStart != this.xEnd) || (this.yStart != this.yEnd))
                {
                    this.label = prompt("Shape label:");
                    shapes.push(this);
                }
                else
                {
                    alert("Curves not saved - zero length");
                }
                activeShape = null;
            }
            select(x, y)
            {
                // capture the curve path
                const path = new Path2D();
                path.moveTo(this.xStart, this.yStart);
                path.quadraticCurveTo(this.xControl, this.yControl, this.xEnd, this.yEnd);
                // Increase line width for a larger hit-test area
                ctx.lineWidth = 10;
                // Perform hit test
                if (ctx.isPointInStroke(path, x, y)) 
                {
                    if(!this.grouped)
                    {
                        this.createHandles();
                    }
                    return(true);
                }
            }
            createHandles()
            {
                this.handles = [];
                this.handles.push(this.placeHandle("start",   this.xStart,   this.yStart));
                this.handles.push(this.placeHandle("control", this.xControl, this.yControl));
                this.handles.push(this.placeHandle("end",     this.xEnd,     this.yEnd));
            }
            selectHandle(x, y)
            {
                let handleSelected = false;
                for(let i = 0; i < this.handles.length; i++)
                {
                    let distance = Math.sqrt(Math.pow((x - this.handles[i].x), 2) + 
                                             Math.pow((y - this.handles[i].y), 2))
                    // Determine if one of the handles has been selected
                    if (distance <= this.handles[i].radius)
                    {
                        handleSelected = true;
                        return(this.handles[i])
                    }
                }
                return(null); 
            }
            clearHandles()
            {
                this.handles = [];
            }
            move(dx, dy)
            {
                this.xStart   += dx;
                this.yStart   += dy;
                this.xControl += dx;
                this.yControl += dy;
                this.xEnd     += dx;
                this.yEnd     += dy;
                // move the handles
                for(let i = 0; i < this.handles.length; i++)
                {
                    this.handles[i].x += dx;
                    this.handles[i].y += dy;
                }
            }
            resize(handle, dx, dy)
            {
                if (handle.location == "start")
                {
                    this.xStart += dx;
                    this.yStart += dy;

                    this.handles[0].x += dx;
                    this.handles[0].y += dy;
                }
                else if (handle.location == "control")
                {
                    this.xControl += dx;
                    this.yControl += dy;

                    this.handles[1].x += dx;
                    this.handles[1].y += dy;
                }   
                else if (handle.location == "end")
                {
                    this.xEnd += dx;
                    this.yEnd += dy;

                    this.handles[2].x += dx;
                    this.handles[2].y += dy;
                }   
            }
            editMenu()
            {
                super.editMenuClear();
                // turn on the display for all edit form fields used by line
                for (let i = 0; i < curve.length; i++) 
                {
                    curve[i].style.display = "inline";
                }
                // prepopulate the shape attribute fields - convert pixels to ft/in
                labelForm.value      = this.label;
                xStartFtForm.value   = Math.trunc(this.xStart / 12) - (extBorder / 12);
                xStartInForm.value   = this.xStart % 12;
                yStartFtForm.value   = Math.trunc(this.yStart / 12) - (extBorder / 12);
                yStartInForm.value   = this.yStart % 12;
                xControlFtForm.value = Math.trunc(this.xControl / 12) - (extBorder / 12);
                xControlInForm.value = this.xControl % 12;
                yControlFtForm.value = Math.trunc(this.yControl / 12) - (extBorder / 12);
                yControlInForm.value = this.yControl % 12;
                xEndFtForm.value     = Math.trunc(this.xEnd / 12) - (extBorder / 12);
                xEndInForm.value     = this.xEnd % 12;
                yEndFtForm.value     = Math.trunc(this.yEnd / 12) - (extBorder / 12);
                yEndInForm.value     = this.yEnd % 12;
                lineWidthForm.value  = this.lineWidth;
                lineStyleForm.value  = this.lineStyle;
                lineColorForm.value  = this.lineColor;
            }
            editSave()
            {
                // update the curve with the new attribute values - convert ft/in to pixels
                this.label     = labelForm.value;
                this.xStart    = (Number(xStartFtForm.value) * 12) + 
                                 (Number(xStartInForm.value) % 12) +
                                 extBorder;
                this.yStart    = (Number(yStartFtForm.value) * 12) + 
                                 (Number(yStartInForm.value) % 12) +
                                 extBorder;
                this.xControl  = (Number(xControlFtForm.value) * 12) + 
                                 (Number(xControlInForm.value) % 12) +
                                 extBorder;
                this.yControl  = (Number(yControlFtForm.value) * 12) + 
                                 (Number(yControlInForm.value) % 12) +
                                 extBorder;
                this.xEnd      = (Number(xEndFtForm.value) * 12) + 
                                 (Number(xEndInForm.value) % 12) +
                                 extBorder;
                this.yEnd      = (Number(yEndFtForm.value) * 12) + 
                                 (Number(yEndInForm.value) % 12) +
                                 extBorder;
                this.lineWidth = Number(lineWidthForm.value);
                this.lineStyle = lineStyleForm.value;
                this.lineColor = lineColorForm.value;
                // update the handles
                this.createHandles();
            }
            duplicate(id)
            {
                const newCurve = new Curve(
                    this.type,
                    id,
                    false,
                    this.label,
                    this.layer,
                    this.nextZIndex,
                    this.lineWidth,
                    this.lineStyle,
                    this.lineColor,
                    this.lineOpacity,
                    this.fill,
                    this.fillColor,
                    this.fillPattern,
                    this.fillOpacity,
                    this.xStart + 20,
                    this.yStart + 20,
                    this.xControl + 20,
                    this.yControl + 20,
                    this.xEnd + 20,
                    this.yEnd + 20,
                    []
                    );
                    return(newCurve);
            }
            showAttributes()
            {
                let xStart   = this.xStart   - extBorder;
                let yStart   = this.yStart   - extBorder;
                let xControl = this.xControl - extBorder;
                let yControl = this.yControl - extBorder;
                let xEnd     = this.xEnd     - extBorder;
                let yEnd     = this.yEnd     - extBorder;

                let length = Math.round(Math.sqrt(Math.pow((this.xEnd - this.xStart), 2) + 
                                                  Math.pow((this.yEnd - this.yStart), 2)))
                let attributes = "<span>" + this.label + ": " +
                                  "start: ("   + pix2ft(xStart)   + ", " + pix2ft(yStart)   + ") " +
                                  "control: (" + pix2ft(xControl) + ", " + pix2ft(yControl) + ") " +
                                  "end: ("     + pix2ft(xEnd)     + ", " + pix2ft(yEnd)     + ") " +
                                  "length: "   + pix2ft(length)   +
                                  "</span>";
                return(attributes);
            }
            draw()
            {
                // setup the drawing parameters
                ctx.lineWidth   = this.lineWidth;
                if(this.lineStyle == 'solid')
                {
                    ctx.setLineDash([]);
                }
                else if(this.lineStyle == 'dashed')
                {
                    ctx.setLineDash([7, 5]);
                }
                else if(this.lineStyle == 'dotted')
                {
                    ctx.setLineDash([2, 4]);
                }
                ctx.strokeStyle = this.lineColor;

                // draw the line
                ctx.beginPath();
                ctx.moveTo(this.xStart, this.yStart);
                ctx.quadraticCurveTo(this.xControl, this.yControl, this.xEnd, this.yEnd);
                ctx.globalAlpha = this.lineOpacity;
                ctx.stroke();

                // draw the label - find the center of the line
                const xShapeCenter = (this.xEnd + this.xStart) / 2;
                const yShapeCenter = (this.yEnd + this.yStart) / 2;
                const maxWidth = Math.sqrt((Math.pow((this.xEnd - this.xStart), 2)) + 
                                           (Math.pow((this.yEnd - this.yStart), 2))) * 0.8;

                ctx.font         = '16px chalkboard';
                ctx.fillStyle    = 'black';
                ctx.textAlign    = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.label, xShapeCenter, yShapeCenter, maxWidth);

                // draw the handles
                if(!this.grouped && this.handles.length > 0)
                {
                    super.drawHandles(this.handles);
                }
            }
            restore(shape_JSON)
            {
                this.type        = shape_JSON.type;
                this.id          = shape_JSON.id;
                this.grouped     = shape_JSON.grouped;
                this.label       = shape_JSON.label;
                this.layer       = shape_JSON.layer;
                this.zIndex      = shape_JSON.zIndex;
                this.lineColor   = shape_JSON.lineColor;
                this.lineStyle   = shape_JSON.lineStyle;
                this.lineWidth   = shape_JSON.lineWidth;
                this.lineOpacity = shape_JSON.lineOpacity;
                this.fill        = shape_JSON.fill;
                this.fillColor   = shape_JSON.fillColor;
                this.fillOpacity = shape_JSON.fillOpacity;
                this.xStart      = shape_JSON.xStart;
                this.yStart      = shape_JSON.yStart;
                this.xControl    = shape_JSON.xControl;
                this.yControl    = shape_JSON.yControl;
                this.xEnd        = shape_JSON.xEnd;
                this.yEnd        = shape_JSON.yEnd;
            }
        }
        class Rectangle extends Shape 
        {
            constructor(type, id, grouped, label, layer, zIndex,
                        lineWidth, lineStyle, lineColor, lineOpacity,
                        fill, fillColor, fillPattern, fillOpacity,
                        x, y, width, height, rotation) 
            {
                super(type, id, grouped, label, layer, zIndex, 
                      lineWidth, lineStyle, lineColor, lineOpacity,
                      fill, fillColor, fillPattern, fillOpacity);
                this.x          = x;
                this.y          = y;
                this.width      = width;
                this.height     = height;
                this.rotation   = rotation;
                this.handles = [];
            }
            createShape(dx, dy)
            {
                this.width  += dx;
                this.height += dy;
            }
            createShapeEnd(x, y)
            {
                // check for either zero width or zero height
                if((this.width != 0) && (this.height != 0))
                {
                    // ensure width is positive
                    if(this.width < 0)
                    {
                        this.width = this.width * -1;
                        this.x = this.x - this.width;
                    }
                    // ensure height is positive
                    if(this.height < 0)
                    {
                        this.height = this.height * -1;
                        this.y = this.y - this.height;
                    }
                    this.label = prompt("Shape label:");
                    shapes.push(this);
                }
                else
                {
                    alert("Rectangle not saved - zero width and/or height");
                }
                activeShape = null;
            }
            select(x, y) 
            {
                // translate mouse click coordinates if shape is rotated
                //   +()cos()sin
                //   +()sin+()cos
                if(this.rotation != 0)
                {
                    const xShapeCenter = this.x + this.width  / 2;
                    const yShapeCenter = this.y + this.height / 2;
                    const theta        = this.rotation * -1;

                    const xTransAbs = Math.trunc(xShapeCenter + 
                                                (xSelectAbs - xShapeCenter) * Math.cos(theta) - 
                                                (ySelectAbs - yShapeCenter) * Math.sin(theta))
                    const yTransAbs = Math.trunc(yShapeCenter + 
                                                (xSelectAbs - xShapeCenter) * Math.sin(theta) + 
                                                (ySelectAbs - yShapeCenter) * Math.cos(theta))         
                    x = xTransAbs;
                    y = yTransAbs;
                }

                // Determine if the selection point is contained within the rectangle
                let selected = false;
                if (x >= this.x && x <= (this.x + this.width) && 
                    y >= this.y && y <= (this.y + this.height))
                {
                    selected = true;
                    // If the rectangle is not a member of a group, create resizing handles.
                    if (!this.grouped)
                    {
                        this.createHandles();
                    }
                }

                return(selected)
            }
            createHandles()
            {
                this.handles = [];
                this.handles.push(this.placeHandle("top-left",      this.x,                this.y));
                this.handles.push(this.placeHandle("top-middle",    this.x + this.width/2, this.y));
                this.handles.push(this.placeHandle("top-right",     this.x + this.width,   this.y));
                this.handles.push(this.placeHandle("right-middle",  this.x + this.width,   this.y + this.height/2));
                this.handles.push(this.placeHandle("bottom-right",  this.x + this.width,   this.y + this.height));
                this.handles.push(this.placeHandle("bottom-middle", this.x + this.width/2, this.y + this.height));
                this.handles.push(this.placeHandle("bottom-left",   this.x,                this.y + this.height));
                this.handles.push(this.placeHandle("left-middle",   this.x,                this.y + this.height/2));
                this.handles.push(this.placeHandle("rotate",        this.x + this.width/2, this.y - 30));
            }
            selectHandle(x, y)
            {
                // translate mouse selection click coordinates if shape is rotated
                //   +()cos()sin
                //   +()sin+()cos
                if(this.rotation != 0)
                {
                    const xShapeCenter = this.x + this.width  / 2;
                    const yShapeCenter = this.y + this.height / 2;
                    const theta        = this.rotation * -1;

                    const xTransAbs = Math.trunc(xShapeCenter + 
                                                (x - xShapeCenter) * Math.cos(theta) - 
                                                (y - yShapeCenter) * Math.sin(theta))
                    const yTransAbs = Math.trunc(yShapeCenter + 
                                                (x - xShapeCenter) * Math.sin(theta) + 
                                                (y - yShapeCenter) * Math.cos(theta))           
                    x = xTransAbs;
                    y = yTransAbs;
                }
                
                let handleSelected = false;
                for(let i = 0; i < this.handles.length; i++)
                {
                    let distance = Math.sqrt(Math.pow((x - this.handles[i].x), 2) + 
                                             Math.pow((y - this.handles[i].y), 2))
                    // Determine if one of the handles has been selected
                    if (distance <= this.handles[i].radius)
                    {
                        handleSelected = true;
                        return(this.handles[i])
                    }
                }
                return(null); 
            }
            clearHandles()
            {
                this.handles = [];
            }
            move(dx, dy)
            {
                this.x += dx;
                this.y += dy;
                // move the handles
                for(let i = 0; i < this.handles.length; i++)
                {
                    this.handles[i].x += dx;
                    this.handles[i].y += dy;
                }
            }
            resize(handle, dx, dy)
            {
                // modify the rectangle based upon the selected handle + mouse movement
                if (handle.location == "top-left")
                {
                    this.x      += dx;
                    this.width  -= dx;
                    this.y      += dy;
                    this.height -= dy;

                    this.handles[0].x += dx;
                    this.handles[0].y += dy;
                    this.handles[1].x += dx / 2;
                    this.handles[1].y += dy;
                    this.handles[2].y += dy;
                    this.handles[3].y += dy / 2;
                    this.handles[5].x += dx / 2;
                    this.handles[6].x += dx;
                    this.handles[7].x += dx;
                    this.handles[7].y += dy / 2;
                    this.handles[8].x += dx / 2;
                    this.handles[8].y += dy;
                }
                else if (handle.location == "top-middle")
                {
                    this.y      += dy;
                    this.height -= dy;

                    this.handles[0].y += dy;
                    this.handles[1].y += dy;
                    this.handles[2].y += dy;
                    this.handles[3].y += dy / 2;
                    this.handles[7].y += dy / 2;
                    this.handles[8].y += dy;
                }
                else if (handle.location == "top-right")
                {
                    this.width  += dx;
                    this.y      += dy;
                    this.height -= dy;

                    this.handles[0].y += dy;
                    this.handles[1].x += dx / 2;
                    this.handles[1].y += dy;
                    this.handles[2].x += dx;
                    this.handles[2].y += dy;
                    this.handles[3].x += dx;
                    this.handles[3].y += dy / 2;
                    this.handles[4].x += dx;
                    this.handles[5].x += dx / 2;
                    this.handles[8].x += dx / 2;
                    this.handles[8].y += dy;
                }
                else if (handle.location == "right-middle")
                {                 
                    this.width += dx;

                    this.handles[1].x += dx / 2;
                    this.handles[2].x += dx;
                    this.handles[3].x += dx;
                    this.handles[4].x += dx;
                    this.handles[5].x += dx / 2;
                    this.handles[8].x += dx / 2;
                }
                else if (handle.location == "bottom-right")
                {
                    this.width  += dx;
                    this.height += dy;

                    this.handles[1].x += dx / 2;
                    this.handles[2].x += dx;
                    this.handles[3].x += dx;
                    this.handles[3].y += dy / 2;
                    this.handles[4].x += dx;
                    this.handles[4].y += dy;
                    this.handles[5].x += dx / 2;
                    this.handles[5].y += dy;
                    this.handles[6].y += dy;
                    this.handles[7].y += dy / 2;
                    this.handles[8].x += dx / 2;
                }
                else if (handle.location == "bottom-middle")
                {
                    this.height += dy;

                    this.handles[3].y += dy / 2;
                    this.handles[4].y += dy;
                    this.handles[5].y += dy;
                    this.handles[6].y += dy;
                    this.handles[7].y += dy / 2;
                }
                else if (handle.location == "bottom-left")
                {
                    this.x      += dx;
                    this.width  -= dx;
                    this.height += dy;

                    this.handles[0].x += dx;
                    this.handles[1].x += dx / 2;
                    this.handles[3].y += dy / 2;
                    this.handles[4].y += dy;
                    this.handles[5].x += dx / 2;
                    this.handles[5].y += dy;
                    this.handles[6].x += dx;
                    this.handles[6].y += dy;
                    this.handles[7].x += dx;
                    this.handles[7].y += dy / 2;
                    this.handles[8].x += dx / 2;
                }
                else if (handle.location == "left-middle")
                {
                    this.x      += dx;
                    this.width  -= dx;

                    this.handles[0].x += dx;
                    this.handles[1].x += dx / 2;
                    this.handles[5].x += dx / 2;
                    this.handles[6].x += dx;
                    this.handles[7].x += dx;
                    this.handles[8].x += dx / 2;
                }
            }
            rotate(dx, dy)
            {
                // set theta to the current  shape rotation angle
                let theta = this.rotation;

                // Determine the amount to rotate the shape based on the mouse movement
                // AR: Find better approach to control the rotation
                theta += (dx + dy) * 0.01;
                // theta = Math.atan2(yMouse - yShapeCenter, xMouse - xShapeCenter);
                // theta = 45 * (Math.PI / 180);

                this.rotation = theta;

                // Set the rotatation angle for all handles associated with the shape
                for(let i = 0; i < this.handles.length; i++)
                {
                    this.handles[i].rotation = theta;
                }
            }
            editMenu()
            {
                super.editMenuClear();
                // turn on the display for all edit form fields used by rectangle
                for (let i = 0; i < rectangle.length; i++) 
                {
                    rectangle[i].style.display = "inline";
                }
                // prepopulate the shape attribute fields
                // - convert pixels to ft/in
                // - convert radians to degrees
                labelForm.value       = this.label;
                xFtForm.value         = Math.trunc(this.x / 12) - (extBorder / 12);
                xInForm.value         = this.x % 12;
                yFtForm.value         = Math.trunc(this.y / 12) - (extBorder / 12);
                yInForm.value         = this.y % 12;
                widthFtForm.value     = Math.trunc(this.width / 12);
                widthInForm.value     = this.width % 12;
                heightFtForm.value    = Math.trunc(this.height / 12);
                heightInForm.value    = this.height % 12;
                rotationForm.value    = Math.round(this.rotation * (180 / Math.PI));
                lineWidthForm.value   = this.lineWidth;
                lineStyleForm.value   = this.lineStyle;
                lineColorForm.value   = this.lineColor;
                lineOpacityForm.value = this.lineOpacity;
                fillColorForm.value   = this.fillColor;
                fillOpacityForm.value = this.fillOpacity;
            }
            editSave()
            {   
                // input error checking
                if(widthFtForm.value == 0 && widthInForm.value == 0)
                {
                    alert("width cannot be zero");
                }
                else if(heightFtForm.value == 0 && heightInForm.value == 0)
                {
                    alert("height cannot be zero");
                }
                else
                {
                    // update the selected rectangle with the new attribute values - convert ft/in to pixels
                    this.label       = labelForm.value;
                    this.x           = (Number(xFtForm.value) * 12) + 
                                       (Number(xInForm.value) % 12) +
                                       extBorder;
                    this.y           = (Number(yFtForm.value) * 12) + 
                                       (Number(yInForm.value) % 12) +
                                       extBorder;
                    this.width       = (Number(widthFtForm.value) * 12) + 
                                       (Number(widthInForm.value) % 12);
                    this.height      = (Number(heightFtForm.value) * 12) + 
                                       (Number(heightInForm.value) % 12);
                    this.rotation    = Number(rotationForm.value) * (Math.PI / 180);
                    this.lineWidth   = Number(lineWidthForm.value);
                    this.lineStyle   = lineStyleForm.value;
                    this.lineColor   = lineColorForm.value;
                    this.lineOpacity = lineOpacityForm.value;
                    this.fillColor   = fillColorForm.value;
                    this.fillOpacity = fillOpacityForm.value;
                    // update the handles
                    this.createHandles();
                }   
            }
            duplicate(id)
            {
                const newRectangle = new Rectangle(
                    this.type,
                    id,
                    false,
                    this.label,
                    this.layer,
                    this.nextZIndex,
                    this.lineWidth,
                    this.lineStyle,
                    this.lineColor,
                    this.lineOpacity,
                    this.fill,
                    this.fillColor,
                    this.fillPattern,
                    this.fillOpacity,
                    this.x + 20,
                    this.y + 20,
                    this.width,
                    this.height,
                    this.rotation,
                    []
                    );
                    return(newRectangle);
            }
            showAttributes()
            {
                let xCenter = this.x + (this.width  / 2) - extBorder;
                let yCenter = this.y + (this.height / 2) - extBorder;
                let rotation = this.rotation * 180 / Math.PI;

                let attributes = "<span>" + this.label + ": " +
                                 "center: ("  + pix2ft(xCenter) + ", " + pix2ft(yCenter) + ") " + 
                                 "width: "    + pix2ft(this.width)  + ") " +
                                 "height: "   + pix2ft(this.height) + ") " +
                                 "rotation: " + rotation.toFixed(1) + " degrees" +
                                 "</span>";
                return(attributes);
            }
            draw()
            {
                // setup the drawing parameters
                ctx.lineWidth   = this.lineWidth;
                if(this.lineStyle == 'solid')
                {
                    ctx.setLineDash([]);
                }
                else if(this.lineStyle == 'dashed')
                {
                    ctx.setLineDash([5, 5]);
                }
                else if(this.lineStyle == 'dotted')
                {
                    ctx.setLineDash([2, 4]);
                }
                ctx.strokeStyle = this.lineColor;
                ctx.fillStyle   = this.fillColor;
                

                // find center of rectangle
                const xShapeCenter = this.x + (this.width  / 2);
                const yShapeCenter = this.y + (this.height / 2);

                if(this.rotation == 0)
                {
                    ctx.globalAlpha = this.lineOpacity;
                    ctx.strokeRect(this.x, this.y, this.width, this.height);
                    if(this.fill)
                    {
                        ctx.globalAlpha = this.fillOpacity;
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                    }
                }
                else
                {
                    // ctx.setTransform(1, 0, 0, 1, 0, 0);
                    //
                    ctx.save();
                    // Translate to rectangle center
                    ctx.translate(xShapeCenter, yShapeCenter);
                    // Rotate
                    ctx.rotate(this.rotation);
                    // Translate back
                    ctx.translate(-xShapeCenter, -yShapeCenter);

                    // Draw the rectangle
                    ctx.strokeRect(this.x, this.y, this.width, this.height);
                    if(this.fill)
                    {
                        ctx.fillRect(this.x, this.y, this.width, this.height);
                    }
                    //
                    ctx.restore();
                }

                // add the label
                const maxWidth = this.width * 0.8;

                ctx.font         = '16px chalkboard';
                ctx.fillStyle    = 'black';
                ctx.textAlign    = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.label, xShapeCenter, yShapeCenter, maxWidth);

                // draw the handles
                if(!this.grouped && this.handles.length > 0)
                {
                    super.drawHandles(this.handles);
                }
            }
            restore(shape_JSON)
            {
                this.type        = shape_JSON.type;
                this.id          = shape_JSON.id;
                this.grouped     = shape_JSON.grouped;
                this.label       = shape_JSON.label;
                this.layer       = shape_JSON.layer;
                this.zIndex      = shape_JSON.zIndex;
                this.lineColor   = shape_JSON.lineColor;
                this.lineStyle   = shape_JSON.lineStyle;
                this.lineWidth   = shape_JSON.lineWidth;
                this.lineOpacity = shape_JSON.lineOpacity;
                this.fill        = shape_JSON.fill;
                this.fillColor   = shape_JSON.fillColor;
                this.fillOpacity = shape_JSON.fillOpacity;
                this.x           = shape_JSON.x;
                this.y           = shape_JSON.y;
                this.width       = shape_JSON.width;
                this.height      = shape_JSON.height;
                this.rotation    = shape_JSON.rotation;
            }
        }
        class Circle    extends Shape 
        {
            constructor(type, id, grouped, label, layer, zIndex,
                        lineWidth, lineStyle, lineColor, lineOpacity,
                        fill, fillColor, fillPattern, fillOpacity,
                        x, y, radius) 
            {
                super(type, id, grouped, label, layer, zIndex, 
                      lineWidth, lineStyle, lineColor, lineOpacity,
                      fill, fillColor, fillPattern, fillOpacity);
                this.x          = x;
                this.y          = y;
                this.radius     = radius;
                this.startAngle = 0;
                this.endAngle   = 2 * Math.PI;
                this.direction  = "clockwise";
                this.handles    = [];
                this.dxAcc  = 0;
                this.dyAcc  = 0;
            }
            createShape(dx, dy)
            {
                this.dxAcc += dx;
                this.dyAcc += dy;
                this.radius = Math.sqrt(Math.pow(this.dxAcc, 2) + Math.pow(this.dyAcc, 2));
            }
            createShapeEnd(x, y)
            {
                if(this.radius != 0)
                {
                    this.label = prompt("Shape label:");
                    shapes.push(this);
                }
                else
                {
                    alert("Circle not saved - zero radius");
                }
                activeShape = null;
            }
            select(x, y) 
            {
                // find the distance of the cursor position from the circle center and compare to the radius
                const distance = Math.sqrt(Math.pow((x - this.x), 2) + Math.pow((y - this.y), 2))

                // If circle is selected, draw handles
                if (!this.grouped && distance <= this.radius)
                {
                    this.createHandles();
                }
                return(distance <= this.radius);
            }
            createHandles()
            {
                this.handles = [];
                this.handles.push(this.placeHandle("top",    this.x,               this.y - this.radius));
                this.handles.push(this.placeHandle("right",  this.x + this.radius, this.y));
                this.handles.push(this.placeHandle("bottom", this.x,               this.y + this.radius));
                this.handles.push(this.placeHandle("left",   this.x - this.radius, this.y));
            }
            selectHandle(x, y)
            {
                let handleSelected = false;
                for(let i = 0; i < this.handles.length; i++)
                {
                    let distance = Math.sqrt(Math.pow((x - this.handles[i].x), 2) + 
                                             Math.pow((y - this.handles[i].y), 2))
                    // Determine if one of the handles has been selected
                    if (distance <= this.handles[i].radius)
                    {
                        handleSelected = true;
                        return(this.handles[i])
                    }
                }
                return(null); 
            }
            clearHandles()
            {
                this.handles = [];
            }
            move(dx, dy)
            {
                this.x += dx;
                this.y += dy;
                // move the handles
                for(let i = 0; i < this.handles.length; i++)
                {
                    this.handles[i].x += dx;
                    this.handles[i].y += dy;
                }
            }
            resize(handle, dx, dy)
            {
                if (handle.location == "top")
                {
                    this.radius -= dy;

                    this.handles[0].y += dy;
                    this.handles[1].x -= dy;
                    this.handles[2].y -= dy;
                    this.handles[3].x += dy;
                }
                else if (handle.location == "right")
                {
                    this.radius += xDelta;

                    this.handles[0].y -= dx;
                    this.handles[1].x += dx;
                    this.handles[2].y += dx;
                    this.handles[3].x -= dx;
                }
                else if (handle.location == "bottom")
                {
                    this.radius += yDelta;

                    this.handles[0].y -= dy;
                    this.handles[1].x += dy;
                    this.handles[2].y += dy;
                    this.handles[3].x -= dy;
                }
                else if (handle.location == "left")
                {
                    this.radius -= xDelta;

                    this.handles[0].y += dx;
                    this.handles[1].x -= dx;
                    this.handles[2].y -= dx;
                    this.handles[3].x += dx;
                }
            }
            editMenu()
            {
                super.editMenuClear();
                // turn on the display for all edit form fields used by circle
                for (let i = 0; i < circle.length; i++) 
                {
                    circle[i].style.display = "inline";
                }
                // prepopulate the shape attribute fields - convert pixels to ft/in
                labelForm.value       = this.label;
                xCenterFtForm.value   = Math.trunc(this.x / 12) - (extBorder / 12);
                xCenterInForm.value   = this.x % 12;
                yCenterFtForm.value   = Math.trunc(this.y / 12) - (extBorder / 12);
                yCenterInForm.value   = this.y % 12;
                radiusFtForm.value    = Math.trunc(this.radius / 12);
                radiusInForm.value    = Math.round(this.radius % 12);
                lineWidthForm.value   = this.lineWidth;
                lineStyleForm.value   = this.lineStyle;
                lineColorForm.value   = this.lineColor; 
                lineOpacityForm.value = this.lineOpacity;
                fillColorForm.value   = this.fillColor; 
                fillOpacityForm.value = this.fillOpacity; 
            }
            editSave()
            {
                // input error checking
                if(radiusFtForm.value == 0 && radiusInForm.value == 0)
                {
                    alert("Error: Radius cannot be zero");
                }
                else
                {
                    // update the selected shape with the new attribute values - convert ft/in to pixels
                    this.label       = labelForm.value;
                    this.x           = (Number(xCenterFtForm.value) * 12) + 
                                       (Number(xCenterInForm.value) % 12) +
                                       extBorder;
                    this.y           = (Number(yCenterFtForm.value) * 12) + 
                                       (Number(yCenterInForm.value) % 12) +
                                       extBorder;
                    this.radius      = (Number(radiusFtForm.value) * 12) + 
                                       (Number(radiusInForm.value) % 12);
                    this.lineWidth   = Number(lineWidthForm.value);
                    this.lineStyle   = lineStyleForm.value;
                    this.lineColor   = lineColorForm.value;
                    this.lineOpacity = lineOpacityForm.value;
                    this.fillColor   = fillColorForm.value;
                    this.fillOpacity = fillOpacityForm.value;
                    // update the handles
                    this.createHandles();
                }
            }
            duplicate(id)
            {
                const newCircle = new Circle(
                    this.type,
                    id,
                    false,
                    this.label,
                    this.layer,
                    this.nextZIndex,
                    this.lineWidth,
                    this.lineStyle,
                    this.lineColor,
                    this.lineOpacity,
                    this.fill,
                    this.fillColor,
                    this.fillPattern,
                    this.fillOpacity,
                    this.x + 20,
                    this.y + 20,
                    this.radius,
                    this.startAngle,
                    this.endAngle,
                    this.direction,
                    []
                    );
                    return(newCircle);
            }
            showAttributes()
            {
                let xCenter = this.x - extBorder;
                let yCenter = this.y - extBorder;

                let attributes = "<span>" + this.label + ": " +
                                 "center: (" + pix2ft(xCenter) + ", " + pix2ft(yCenter)+ ") " +
                                 "radius: "  + pix2ft(this.radius) +
                                 "</span>";
                return(attributes);
            }
            toBack()
            {

            }   
            toFront(zIndex)
            {
                this.zIndex = zIndex;
            }      
            draw()
            {
                // setup the drawing parameters
                ctx.lineWidth   = this.lineWidth;
                if(this.lineStyle == 'solid')
                {
                    ctx.setLineDash([]);
                }
                else if(this.lineStyle == 'dashed')
                {
                    ctx.setLineDash([5, 5]);
                }
                else if(this.lineStyle == 'dotted')
                {
                    ctx.setLineDash([2, 4]);
                }
                ctx.strokeStyle = this.lineColor;
                ctx.fillStyle   = this.fillColor;

                // draw the circle
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, this.startAngle, this.endAngle, this.direction);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.lineOpacity;
                ctx.stroke();
                if(this.fill)
                {
                    ctx.globalAlpha = this.fillOpacity;
                    ctx.fill();
                }

                // add the label
                const maxWidth = this.radius * 2;
                ctx.font         = '16px chalkboard';
                ctx.fillStyle    = 'black';
                ctx.textAlign    = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.label, this.x, this.y, maxWidth);

                // draw the handles only if this is currently selected and is not a grouped shape
                if(!this.grouped && this.handles.length > 0)
                {
                    super.drawHandles(this.handles);
                }
            }
            restore(shape_JSON)
            {
                this.type        = shape_JSON.type;
                this.id          = shape_JSON.id;
                this.grouped     = shape_JSON.grouped;
                this.label       = shape_JSON.label;
                this.layer       = shape_JSON.layer;
                this.zIndex      = shape_JSON.zIndex;
                this.lineColor   = shape_JSON.lineColor;
                this.lineStyle   = shape_JSON.lineStyle;
                this.lineWidth   = shape_JSON.lineWidth;
                this.lineOpacity = shape_JSON.lineOpacity;
                this.fill        = shape_JSON.fill;
                this.fillColor   = shape_JSON.fillColor;
                this.fillOpacity = shape_JSON.fillOpacity;
                this.x           = shape_JSON.x;
                this.y           = shape_JSON.y;
                this.radius      = shape_JSON.radius;
            }
        }
        class Ellipse   extends Shape
        {
            constructor(type, id, grouped, label, layer, zIndex,
                        lineWidth, lineStyle, lineColor, lineOpacity,
                        fill, fillColor, fillPattern, fillOpacity,
                        x, y, xRadius, yRadius, rotation) 
            {
                super(type, id, grouped, label, layer, zIndex, 
                      lineWidth, lineStyle, lineColor, lineOpacity,
                      fill, fillColor, fillPattern, fillOpacity);
                this.x          = x;
                this.y          = y;
                this.xRadius    = xRadius;
                this.yRadius    = yRadius;
                this.rotation   = rotation;
                // 
                this.startAngle = 0;
                this.endAngle   = 2 * Math.PI;
                this.direction  = "clockwise";
                //
                this.handles    = [];
                this.dxAcc  = 0;
                this.dyAcc  = 0;
            }
            createShape(dx, dy)
            {
                this.dxAcc += dx;
                this.dyAcc += dy;
                this.xRadius = Math.abs(this.dxAcc);
                this.yRadius = Math.abs(this.dyAcc);
            }
            createShapeEnd(x, y)
            {
                if(this.xRadius != 0 || this.yRadius)
                {
                    this.label = prompt("Shape label:");
                    shapes.push(this);
                }
                else
                {
                    alert("Ellipse not saved - zero radius");
                }
                activeShape = null;
            }
            select(x, y) 
            {
                const dx = x - this.x;
                const dy = y - this.y;
                const selected = (dx * dx) / (this.xRadius * this.xRadius) + 
                                 (dy * dy) / (this.yRadius * this.yRadius) <= 1;

                // If ellipse is selected, draw handles
                if (!this.grouped && selected)
                {
                    this.createHandles();
                }
                return(selected);
            }
            createHandles()
            {
                this.handles = [];
                this.handles.push(this.placeHandle("top",    this.x,                this.y - this.yRadius));
                this.handles.push(this.placeHandle("right",  this.x + this.xRadius, this.y));
                this.handles.push(this.placeHandle("bottom", this.x,                this.y + this.yRadius));
                this.handles.push(this.placeHandle("left",   this.x - this.xRadius, this.y));
            }
            selectHandle(x, y)
            {
                let handleSelected = false;
                for(let i = 0; i < this.handles.length; i++)
                {
                    let distance = Math.sqrt(Math.pow((x - this.handles[i].x), 2) + 
                                             Math.pow((y - this.handles[i].y), 2))
                    // Determine if one of the handles has been selected
                    if (distance <= this.handles[i].radius)
                    {
                        handleSelected = true;
                        return(this.handles[i])
                    }
                }
                return(null); 
            }
            clearHandles()
            {
                this.handles = [];
            }
            move(dx, dy)
            {
                this.x += dx;
                this.y += dy;
                // move the handles
                for(let i = 0; i < this.handles.length; i++)
                {
                    this.handles[i].x += dx;
                    this.handles[i].y += dy;
                }
            }
            resize(handle, dx, dy)
            {
                if (handle.location == "top")
                {
                    this.yRadius -= dy;

                    this.handles[0].y += dy;
                    this.handles[2].y -= dy;
                }
                else if (handle.location == "right")
                {
                    this.xRadius += xDelta;

                    this.handles[1].x += dx;
                    this.handles[3].x -= dx;
                }
                else if (handle.location == "bottom")
                {
                    this.yRadius += yDelta;

                    this.handles[0].y -= dy;
                    this.handles[2].y += dy;
                }
                else if (handle.location == "left")
                {
                    this.xRadius -= xDelta;

                    this.handles[1].x -= dx;
                    this.handles[3].x += dx;
                }
            }
            editMenu()
            {
                super.editMenuClear();
                // turn on the display for all edit form fields used by the ellipse
                for (let i = 0; i < ellipse.length; i++) 
                {
                    ellipse[i].style.display = "inline";
                }
                // prepopulate the shape attribute fields - convert pixels to ft/in
                labelForm.value       = this.label;
                xCenterFtForm.value   = Math.trunc(this.x / 12) - (extBorder / 12);
                xCenterInForm.value   = this.x % 12;
                yCenterFtForm.value   = Math.trunc(this.y / 12) - (extBorder / 12);
                yCenterInForm.value   = this.y % 12;
                xRadiusFtForm.value   = Math.trunc(this.xRadius / 12);
                xRadiusInForm.value   = Math.round(this.xRadius % 12);
                yRadiusFtForm.value   = Math.trunc(this.yRadius / 12);
                yRadiusInForm.value   = Math.round(this.yRadius % 12);
                lineWidthForm.value   = this.lineWidth;
                lineStyleForm.value   = this.lineStyle;
                lineColorForm.value   = this.lineColor;
                lineOpacityForm.value = this.lineOpacity; 
                fillColorForm.value   = this.fillColor; 
                fillOpacityForm.value = this.fillOpacity; 
            }
            editSave()
            {
                // input error checking
                if(xRadiusFtForm.value == 0 && xRadiusInForm.value == 0)
                {
                    alert("Error: X radius cannot be zero");
                }
                else if(yRadiusFtForm.value == 0 && yRadiusInForm.value == 0)
                {
                    alert("Error: Y radius cannot be zero");
                }
                else
                {
                    // update the selected shape with the new attribute values 
                    // - convert ft/in to pixels
                    this.label       = labelForm.value;
                    this.x           = (Number(xCenterFtForm.value) * 12) + 
                                       (Number(xCenterInForm.value) % 12) +
                                       extBorder;
                    this.y           = (Number(yCenterFtForm.value) * 12) + 
                                       (Number(yCenterInForm.value) % 12) +
                                       extBorder;
                    this.xRadius     = (Number(xRadiusFtForm.value) * 12) + 
                                       (Number(xRadiusInForm.value) % 12);
                    this.yRadius     = (Number(yRadiusFtForm.value) * 12) + 
                                       (Number(yRadiusInForm.value) % 12);
                    this.lineWidth   = Number(lineWidthForm.value);
                    this.lineStyle   = lineStyleForm.value;
                    this.lineColor   = lineColorForm.value;
                    this.lineOpacity = lineOpacityForm.value;
                    this.fillColor   = fillColorForm.value;
                    this.fillOpacity = fillOpacityForm.value;
                    // update the handles
                    this.createHandles();
                }
            }
            duplicate(id)
            {
                const newEllipse = new Ellipse(
                    this.type,
                    id,
                    false,
                    this.label,
                    this.layer,
                    this.nextZIndex,
                    this.lineWidth,
                    this.lineStyle,
                    this.lineColor,
                    this.lineOpacity,
                    this.fill,
                    this.fillColor,
                    this.fillPattern,
                    this.fillOpacity,
                    this.x + 20,
                    this.y + 20,
                    this.xRadius,
                    this.yRadius,
                    this.rotation
                    );
                    return(newEllipse);
            }
            showAttributes()
            {
                let xCenter = this.x - extBorder;
                let yCenter = this.y - extBorder;

                let attributes = "<span>" + this.label + ": " +
                                 "center: (" + pix2ft(xCenter) + ", " + pix2ft(yCenter)+ ") " +
                                 "x radius: "  + pix2ft(this.xRadius) +
                                 "y radius: "  + pix2ft(this.yRadius) +
                                 "</span>";
                return(attributes);
            }
            draw()
            {
                // setup the drawing parameters
                ctx.lineWidth   = this.lineWidth;
                if(this.lineStyle == 'solid')
                {
                    ctx.setLineDash([]);
                }
                else if(this.lineStyle == 'dashed')
                {
                    ctx.setLineDash([5, 5]);
                }
                else if(this.lineStyle == 'dotted')
                {
                    ctx.setLineDash([2, 4]);
                }
                ctx.strokeStyle = this.lineColor;
                ctx.fillStyle   = this.fillColor;

                // draw the ellipse
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.xRadius, this.yRadius, this.rotation, 
                            this.startAngle, this.endAngle, false);
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.lineOpacity;
                ctx.stroke();
                if(this.fill)
                {
                    ctx.globalAlpha = this.fillOpacity;
                    ctx.fill();
                }

                // add the label
                const maxWidth = this.xRadius * 2;
                ctx.font         = '16px chalkboard';
                ctx.fillStyle    = 'black';
                ctx.textAlign    = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.label, this.x, this.y, maxWidth);

                // draw the handles only if this is currently selected and is not a grouped shape
                if(!this.grouped && this.handles.length > 0)
                {
                    super.drawHandles(this.handles);
                }
            }
            restore(shape_JSON)
            {
                this.type        = shape_JSON.type;
                this.id          = shape_JSON.id;
                this.grouped     = shape_JSON.grouped;
                this.label       = shape_JSON.label;
                this.layer       = shape_JSON.layer;
                this.zIndex      = shape_JSON.zIndex;
                this.lineColor   = shape_JSON.lineColor;
                this.lineStyle   = shape_JSON.lineStyle;
                this.lineWidth   = shape_JSON.lineWidth;
                this.lineOpacity = shape_JSON.lineOpacity;
                this.fill        = shape_JSON.fill;
                this.fillColor   = shape_JSON.fillColor;
                this.fillOpacity = shape_JSON.fillOpacity;
                this.x           = shape_JSON.x;
                this.y           = shape_JSON.y;
                this.xRadius     = shape_JSON.xRadius;
                this.yRadius     = shape_JSON.yRadius;
                this.rotation    = shape_JSON.rotation;
            }
        }
        class Polygon   extends Shape 
        {
            constructor(type, id, grouped, label, layer, zIndex,
                        lineWidth, lineStyle, lineColor, lineOpacity,
                        fill, fillColor, fillPattern, fillOpacity,
                        vertices = [], rotation, status) 
            {
                super(type, id, grouped, label, layer, zIndex, 
                      lineWidth, lineStyle, lineColor, lineOpacity,
                      fill, fillColor, fillPattern, fillOpacity);
                this.vertices   = vertices;
                this.rotation   = rotation;
                this.status     = status;
                this.handles    = [];
                this.xPolygonVertex = 0;
                this.yPolygonVertex = 0;
            }
            createShape(dx, dy)
            {
                this.xPolygonVertex += dx;
                this.yPolygonVertex += dy;
                this.vertices[this.vertices.length - 1] = { x : this.xPolygonVertex, 
                                                            y : this.yPolygonVertex};
            }
            createShapeEnd(x, y)
            {
                // Determine if the polygon is being closed
                const xPolygonStart = this.vertices[0].x;
                const yPolygonStart = this.vertices[0].y;
                const xPolygonDistance = Math.abs(xPolygonStart - x);
                const yPolygonDistance = Math.abs(yPolygonStart - y);

                if (xPolygonDistance < 8 && yPolygonDistance < 8)
                {
                    ctx.closePath();
                    this.status = "closed";
                    // since the polygon has been closed remove the last point
                    this.vertices.pop();
                    this.label = prompt("Shape label:");
                    shapes.push(this);
                    polygonWIP = false;
                    activeShape = null;
                }
            }
            select(x, y) 
            {
                // Create the path for the target polygon
                ctx.beginPath();
                ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
                for (let j = 1; j < this.vertices.length; j++) 
                {
                    ctx.lineTo(this.vertices[j].x, this.vertices[j].y);
                }
                ctx.closePath();

                // If the polygon is selected, draw handles
                if(!this.grouped && ctx.isPointInPath(x, y))
                {
                    this.createHandles();
                }

                // return 'true' if the X-Y coordinates are contained within the polygon
                return(ctx.isPointInPath(x, y));
            }
            createHandles()
            {
                this.handles = [];
                for (let j = 0; j < this.vertices.length; j++)
                {
                    this.handles.push(this.placeHandle("v" + j, this.vertices[j].x, this.vertices[j].y));
                }
            }
            selectHandle(x, y)
            {
                let handleSelected = false;
                for(let i = 0; i < this.handles.length; i++)
                {
                    let distance = Math.sqrt(Math.pow((x - this.handles[i].x), 2) + 
                                             Math.pow((y - this.handles[i].y), 2))
                    // Determine if one of the handles has been selected
                    if (distance <= this.handles[i].radius)
                    {
                        handleSelected = true;
                        return(this.handles[i])
                    }
                }
                return(null); 
            }
            clearHandles()
            {
                this.handles = [];
            }
            move(dx, dy)
            {
                for(let i = 0; i < this.vertices.length; i++)
                {
                    this.vertices[i].x += xDelta;
                    this.vertices[i].y += yDelta;
                }
                // move the handles
                for(let i = 0; i < this.handles.length; i++)
                {
                    this.handles[i].x += dx;
                    this.handles[i].y += dy;
                }
            }
            resize(handle, dx, dy)
            {
                for(let i = 0; i < this.vertices.length; i++)
                {    
                    if (handle.location == "v" + i)
                    {
                        this.vertices[i].x += dx;
                        this.vertices[i].y += dy;

                        this.handles[i].x += dx;
                        this.handles[i].y += dy;
                    }
                }
            }
            editMenu()
            {
                super.editMenuClear();
                // turn on the display for all edit form fields used by polygon
                for (let i = 0; i < polygon.length; i++) 
                {
                    polygon[i].style.display = "inline";
                }
                // Go through all vertices and construct html input form elements
                let polyHTML = '';
                for (let i = 0; i < this.vertices.length; i++) 
                {
                    polyHTML += '<label for="xV' + i + 'Ft" style="display: inline-block; width: 80px;">v' + i + ' x: </label>\n' +
                            '<input type="number" class="xVFt" name="xV"' + i + '"Ft" style="width: 50px;">\n' +
                            '<span>ft</span>\n' +
                            '<input type="number" class="xVIn" name="xV"' + i + '"In" style="width: 50px;">\n' +
                            '<span>in</span>\n' +
                            '<br>\n' +
                            '<label for="yV' + i + 'Ft" style="display: inline-block; width: 80px;">v' + i + ' y: </label>\n' +
                            '<input type="number" class="yVFt" name="yV"' + i + '"Ft" style="width: 50px;">\n' +
                            '<span>ft</span>\n' +
                            '<input type="number" class="yVIn" name="yV"' + i + '"In" style="width: 50px;">\n' +
                            '<span>in</span>\n' +
                            '<br>\n'
                }
                polygonHTML.innerHTML = polyHTML;

                const xVFt = document.getElementsByClassName('xVFt');
                const xVIn = document.getElementsByClassName('xVIn');
                const yVFt = document.getElementsByClassName('yVFt');
                const yVIn = document.getElementsByClassName('yVIn');

                // prepopulate the shape attribute fields - convert pixels to ft/in
                labelForm.value     = this.label;
                // walk through each vertex, convert pixels to ft/in, and set form field
                for (let i = 0; i < xVFt.length; i++) 
                {
                    xVFt[i].value = Math.trunc(this.vertices[i].x / 12) - (extBorder / 12);
                    xVIn[i].value = this.vertices[i].x % 12;
                    yVFt[i].value = Math.trunc(this.vertices[i].y / 12) - (extBorder / 12);
                    yVIn[i].value = this.vertices[i].y % 12;
                }

                lineWidthForm.value   = this.lineWidth;
                lineStyleForm.value   = this.lineStyle;
                lineColorForm.value   = this.lineColor;
                lineOpacityForm.value = this.lineOpacity;
                fillColorForm.value   = this.fillColor;
                fillOpacityForm.value = this.fillOpacity;
            }
            editSave()
            {
                //
                const xVFt = document.getElementsByClassName('xVFt');
                const xVIn = document.getElementsByClassName('xVIn');
                const yVFt = document.getElementsByClassName('yVFt');
                const yVIn = document.getElementsByClassName('yVIn');

                // update the selected shape with the new attribute values
                this.label     = labelForm.value;
                // walk through vertex, convert ft/in to pixels, and save to selected polygon
                for (let i = 0; i < xVFt.length; i++)
                {
                    this.vertices[i].x = (Number(xVFt[i].value) * 12) + 
                                         (Number(xVIn[i].value) % 12) +
                                         extBorder;
                    this.vertices[i].y = (Number(yVFt[i].value) * 12) + 
                                         (Number(yVIn[i].value) % 12) +
                                         extBorder;
                }
                this.lineWidth   = Number(lineWidthForm.value);
                this.lineStyle   = lineStyleForm.value;
                this.lineColor   = lineColorForm.value;
                this.lineOpacity = lineOpacityForm.value;
                // update the handles
                this.fillColor   = fillColorForm.value;
                this.fillOpacity = fillOpacityForm.value;
                // update the handles
                this.createHandles();
            }
            duplicate(id)
            {
                const newPolygon = new Polygon(
                    this.type,
                    id,
                    false,
                    this.label,
                    this.layer,
                    this.nextZIndex,
                    this.lineWidth,
                    this.lineStyle,
                    this.lineColor,
                    this.lineOpacity,
                    this.fill,
                    this.fillColor,
                    this.fillPattern,
                    this.fillOpacity,
                    [],
                    this.rotation,
                    this.status,
                    []
                    );
                for (let i = 0; i < this.vertices.length; i++)
                {
                    newPolygon.vertices.push({x : this.vertices[i].x + 20, 
                                              y : this.vertices[i].y + 20});
                }
                return(newPolygon);
            }
            showAttributes()
            {
                let vertices = "";
                for(let i = 0; i < this.vertices.length; i++)
                {
                    vertices += "v" + i + ": (" + 
                                pix2ft(this.vertices[0].x - extBorder) + ", " + 
                                pix2ft(this.vertices[0].y - extBorder) + "), "
                }
                let attributes = "<span>" + this.label + ": " + vertices + "</span>";
                return(attributes);
            }
            draw()
            {
                // setup the drawing parameters
                ctx.lineWidth   = this.lineWidth;
                if(this.lineStyle == 'solid')
                {
                    ctx.setLineDash([]);
                }
                else if(this.lineStyle == 'dashed')
                {
                    ctx.setLineDash([7, 5]);
                }
                else if(this.lineStyle == 'dotted')
                {
                    ctx.setLineDash([2, 4]);
                }
                ctx.strokeStyle = this.lineColor;
                ctx.fillStyle   = this.fillColor;
                // draw the polygon
                ctx.beginPath();
                ctx.moveTo(this.vertices[0].x, this.vertices[0].y);

                if(this.vertices.length > 1)
                {
                    for(let i = 1; i < this.vertices.length; i++)
                    {
                        ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
                    }
                }
                if(this.status == "closed")
                {
                    ctx.closePath();
                    if(this.fill)
                    {
                        ctx.globalAlpha = this.fillOpacity;
                        ctx.fill();
                    }
                }
                ctx.globalAlpha = this.lineOpacity;
                ctx.stroke();

                // if the polygon drawing is done, add the label
                if (this.status == "closed")
                {
                    // find center of polygon
                    let sumX = 0;
                    let sumY = 0;
                    for (let i = 0; i < this.vertices.length; i++) 
                    {
                        sumX += this.vertices[i].x;
                        sumY += this.vertices[i].y;
                    }

                    const xShapeCenter = sumX / this.vertices.length;
                    const yShapeCenter = sumY / this.vertices.length;

                    const maxWidth = 100;

                    ctx.font         = '16px chalkboard';
                    ctx.fillStyle    = 'black';
                    ctx.textAlign    = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.label, xShapeCenter, yShapeCenter, maxWidth);
                }

                // draw the handles
                if(!this.grouped && this.handles.length > 0)
                {
                    super.drawHandles(this.handles);
                }
            }
            restore(shape_JSON)
            {
                this.type        = shape_JSON.type;
                this.id          = shape_JSON.id;
                this.grouped     = shape_JSON.grouped;
                this.label       = shape_JSON.label;
                this.layer       = shape_JSON.layer;
                this.zIndex      = shape_JSON.zIndex;
                this.lineColor   = shape_JSON.lineColor;
                this.lineStyle   = shape_JSON.lineStyle;
                this.lineWidth   = shape_JSON.lineWidth;
                this.lineOpacity = shape_JSON.lineOpacity;
                this.fill        = shape_JSON.fill;
                this.fillColor   = shape_JSON.fillColor;
                this.fillOpacity = shape_JSON.fillOpacity;
                for(let i = 0; i < shape_JSON.vertices.length; i++)
                {
                    this.vertices.push(shape_JSON.vertices[i]);
                }
                this.rotation  = shape_JSON.rotation;
                this.status    = shape_JSON.status;
            }
        }
        
        class Plant
        {
            constructor(plant, type, id, grouped = false, label, layer, zIndex,
                        shape, lineWidth, lineStyle, lineColor, lineOpacity,
                        fill, fillColor, fillPattern, fillOpacity,
                        x, y)
            {
                //
                this.plant   = plant;
                this.type    = type;
                this.id      = id;
                this.grouped = grouped;
                this.label   = label;
                this.layer   = "tbd";
                this.zIndex  = zIndex,
                // Plant details downloaded from server
                this.commonName  = "";
                this.height_feet = 0;
                this.height_inch = 0;
                this.width_feet  = 0;
                this.width_inch  = 0;
                // 
                this.shape   = new Circle('circle',    // type
                                          99,          // id
                                          false,       // grouped
                                          '',          // label
                                          layer,       // layer
                                          zIndex,      // z index
                                          lineWidth,   // linewidth
                                          lineStyle,   // linestyle
                                          lineColor,   // line color
                                          lineOpacity, // line opacity
                                          fill,        // fill
                                          fillColor,   // fill color
                                          fillPattern, // fill pattern
                                          fillOpacity, // fill opacity
                                          200,         // x center
                                          200,         // y center
                                          40);         // radius placeholder
            }
            fetchDetails()
            {
                // Fetch the plant details and create new javascript plant object
                const url = "{% url 'plants:plant_fetch' %}"
                const requestMethod = "POST";
                const csrfToken     = document.querySelector('[name=csrfmiddlewaretoken]').value;
                const postData      = { requestedPlant : this.plant }
                let downloadedPlant;

                fetch(url,
                {
                    method: requestMethod,
                    headers: 
                    {
                        // Tells the server that the request body is in JSON format
                        'Content-Type': 'application/json',
                        //  Provides CSRF protection, necessary for Django
                        'X-CSRFToken' : csrfToken
                    },
                    // Convert the dictionary to a JSON string
                    body: JSON.stringify(postData),
                })
                .then(response => response.text())
                .then(newPlantJSON => 
                {
                    // AR: Convert the array of one object to just an object - remove '[]'
                    const tempPlantObject = JSON.parse(newPlantJSON);
                    downloadedPlant = tempPlantObject[0];

                    // Populate the plant data fields
                    this.commonName   = downloadedPlant.commonName;
                    this.genus        = downloadedPlant.genus;
                    this.species      = downloadedPlant.species;
                    this.type_x       = downloadedPlant.type_x;
                    this.bloom_color  = downloadedPlant.bloom_color;
                    this.bloom_season = downloadedPlant.bloom_season;
                    this.pollinators  = downloadedPlant.pollinators;
                    this.height_feet  = downloadedPlant.height_feet;
                    this.height_inch  = downloadedPlant.height_inch;
                    this.width_feet   = downloadedPlant.width_feet;
                    this.width_inch   = downloadedPlant.width_inch;
                    this.sun_exposure = downloadedPlant.sun_exposure;
                    this.water_rqmts  = downloadedPlant.water_rqmts;
                    this.pH_min       = downloadedPlant.pH_min;
                    this.pH_max       = downloadedPlant.pH_max;
                    this.soil_type    = downloadedPlant.soil_type;
                    this.heat_tolerance = downloadedPlant.heat_tolerance;
                    // Populate the plant shape fields
                    this.shape.label  = this.commonName;
                    this.shape.radius = (this.width_feet * 12 + this.width_inch) / 2;
                    // Refresh the screen to show the newly added plant
                    drawScreen();
                });
            }
            getModal()
            {
                let url             = "{% url 'plants:plant_details_modal' %}";
                const requestMethod = "POST";
                const csrfToken     = document.querySelector('[name=csrfmiddlewaretoken]').value;
                const postData      = { requestedPlant : this.plant }
                const plant_details_modal = document.getElementById('plant_details_modal');

                // Fetch the plant details modal
                fetch(url, 
                {
                    method: requestMethod,
                    headers:
                    {
                        // Tells the server that the request body is in JSON format
                        'Content-Type': 'application/json',
                        //  Provides CSRF protection, necessary for Django
                        'X-CSRFToken' : csrfToken
                    },
                    // Convert the dictionary to a JSON string
                    body: JSON.stringify(postData),
                })
                .then(response => response.text())
                .then(html => { plant_details_modal.innerHTML = html; })
                // enable the model display
                plant_details_modal.style.display = 'block';
            }
            select(x, y)
            {
                return(this.shape.select(x, y));
            }
            selectHandle(x, y)
            {
                return(this.shape.selectHandle(x, y));
            }
            clearHandles()
            {
                this.shape.clearHandles();
            }
            move(dx, dy)
            {
                this.shape.move(dx, dy);   
            }
            resize(dx, dy)
            {
                this.shape.resize(dx, dy);   
            }
            duplicate(id)
            {
                const duplicatePlant = new Plant(this.commonName, 
                                                 this.type, 
                                                 nextPlantID, 
                                                 this.grouped, 
                                                 this.commonName, 
                                                 this.layer,
                                                 this.nextZIndex,
                                                 "circle");
                // Populate the plant data fields
                duplicatePlant.commonName   = this.commonName;
                duplicatePlant.genus        = this.genus;
                duplicatePlant.species      = this.species;
                duplicatePlant.type_x       = this.type_x;
                duplicatePlant.bloom_color  = this.bloom_color;
                duplicatePlant.bloom_season = this.bloom_season;
                duplicatePlant.pollinators  = this.pollinators;
                duplicatePlant.height_feet  = this.height_feet;
                duplicatePlant.height_inch  = this.height_inch;
                duplicatePlant.width_feet   = this.width_feet;
                duplicatePlant.width_inch   = this.width_inch;
                duplicatePlant.sun_exposure = this.sun_exposure;
                duplicatePlant.water_rqmts  = this.water_rqmts;
                duplicatePlant.pH_min       = this.pH_min;
                duplicatePlant.pH_max       = this.pH_max;
                duplicatePlant.soil_type    = this.soil_type;
                duplicatePlant.heat_tolerance = this.heat_tolerance;
                // Populate the plant shape fields
                duplicatePlant.shape.label  = this.commonName;
                duplicatePlant.shape.radius = (this.width_feet * 12 + this.width_inch) / 2;

                duplicatePlant.shape.x = this.shape.x + 20;
                duplicatePlant.shape.y = this.shape.y + 20
                shapes.push(duplicatePlant);
            }
            showAttributes()
            {
                let xCenter = this.shape.x - extBorder;
                let yCenter = this.shape.y - extBorder;

                let attributes = "<p>" + 
                                 "Common Name: " + this.commonName + " " +
                                 "center: (" + pix2ft(xCenter) + ", " + pix2ft(yCenter)+ ") " +
                                 "width: "   + pix2ft(this.shape.radius) +
                                 "</p>";
                return(attributes);
            }
            draw()
            {
                // pass down the value of the grouped flag to the shape used to depict the plant
                this.shape.grouped = this.grouped;
                this.shape.draw();
            }
            restore(shape_JSON)
            {
                // 
                this.plant       = shape_JSON.plant;
                this.type        = shape_JSON.type;
                this.id          = shape_JSON.id;
                this.grouped     = shape_JSON.grouped;
                this.label       = shape_JSON.label;
                this.layer       = shape_JSON.layer;
                this.zIndex      = shape_JSON.zIndex;
                // Get the up-to-date plant information
                this.fetchDetails(shape_JSON.plant);
                //
                this.shape.label       = shape_JSON.plant;
                this.shape.lineWidth   = shape_JSON.shape.lineWidth;
                this.shape.lineStyle   = shape_JSON.shape.lineStyle;
                this.shape.lineColor   = shape_JSON.shape.lineColor;
                this.shape.lineOpacity = shape_JSON.shape.lineOpacity;
                this.shape.fill        = shape_JSON.shape.fill;
                this.shape.fillColor   = shape_JSON.shape.fillColor;
                this.shape.fillOpacity = shape_JSON.shape.fillOpacity;
                this.shape.x           = shape_JSON.shape.x;
                this.shape.y           = shape_JSON.shape.y;
                this.shape.radius      = shape_JSON.shape.radius;
            }
        }

        class ShapeGroup 
        {
            constructor(id, zIndex, layer)
            {
                this.type   = "group";
                this.id     = id;
                this.zIndex = zIndex;
                this.layer  = layer;
                this.shapes = [];
                //
                this.boundingBox = new Rectangle();
            }
            addShape(shape)
            {
                this.shapes.push(shape);
            }
            createBoundingBox()
            {
                // determine coordinates of bounding box
                let xMin = 10000;
                let yMin = 10000;
                let xMax = -1000;
                let yMax = -1000;
                for(let i=0; i < this.shapes.length; i++)
                {
                    if(this.shapes[i].type == "plant")
                    {
                        xMin = Math.min(xMin, this.shapes[i].shape.x - this.shapes[i].shape.radius);
                        yMin = Math.min(yMin, this.shapes[i].shape.y - this.shapes[i].shape.radius);
                        xMax = Math.max(xMax, this.shapes[i].shape.x + this.shapes[i].shape.radius);
                        yMax = Math.max(yMax, this.shapes[i].shape.y + this.shapes[i].shape.radius);
                    }
                    else if(this.shapes[i].type == "line")
                    {
                        xMin = Math.min(xMin, this.shapes[i].xStart, this.shapes[i].xEnd);
                        yMin = Math.min(yMin, this.shapes[i].yStart, this.shapes[i].yEnd);
                        xMax = Math.max(xMax, this.shapes[i].xStart, this.shapes[i].xEnd);
                        yMax = Math.max(yMax, this.shapes[i].yStart, this.shapes[i].yEnd);
                    }
                    else if(this.shapes[i].type == "curve")
                    {
                        xMin = Math.min(xMin, this.shapes[i].xStart, this.shapes[i].xEnd);
                        yMin = Math.min(yMin, this.shapes[i].yStart, this.shapes[i].yEnd);
                        xMax = Math.max(xMax, this.shapes[i].xStart, this.shapes[i].xEnd);
                        yMax = Math.max(yMax, this.shapes[i].yStart, this.shapes[i].yEnd);
                    }
                    
                    else if(this.shapes[i].type == "rectangle")
                    {
                        xMin = Math.min(xMin, this.shapes[i].x);
                        yMin = Math.min(yMin, this.shapes[i].y);
                        xMax = Math.max(xMax, this.shapes[i].x + this.shapes[i].width);
                        yMax = Math.max(yMax, this.shapes[i].y + this.shapes[i].height);
                    }
                    else if(this.shapes[i].type == "circle")
                    {
                        xMin = Math.min(xMin, this.shapes[i].x - this.shapes[i].radius);
                        yMin = Math.min(yMin, this.shapes[i].y - this.shapes[i].radius);
                        xMax = Math.max(xMax, this.shapes[i].x + this.shapes[i].radius);
                        yMax = Math.max(yMax, this.shapes[i].y + this.shapes[i].radius);
                    }
                    else if(this.shapes[i].type == "ellipse")
                    {
                        xMin = Math.min(xMin, this.shapes[i].x - this.shapes[i].xRadius);
                        yMin = Math.min(yMin, this.shapes[i].y - this.shapes[i].yRadius);
                        xMax = Math.max(xMax, this.shapes[i].x + this.shapes[i].xRadius);
                        yMax = Math.max(yMax, this.shapes[i].y + this.shapes[i].yRadius);
                    }
                    else if(this.shapes[i].type == "polygon")
                    {
                        for(let j = 0; j < this.shapes[i].vertices.length; j++)
                        {
                            xMin = Math.min(xMin, this.shapes[i].vertices[j].x);
                            yMin = Math.min(yMin, this.shapes[i].vertices[j].y);
                            xMax = Math.max(xMax, this.shapes[i].vertices[j].x);
                            yMax = Math.max(yMax, this.shapes[i].vertices[j].y);
                        }
                    }
                }
                //
                const boundingBoxPadding = 20;
                // create bounding box
                this.boundingBox.type        = 'rectangle';
                this.boundingBox.id          = 0;
                this.boundingBox.grouped     = false;
                this.boundingBox.label       = '';
                this.boundingBox.layer       = "ground";            
                this.boundingBox.lineWidth   = 1;
                this.boundingBox.lineStyle   = "dashed";
                this.boundingBox.lineColor   = "black";
                this.boundingBox.lineOpacity = 1.0;
                this.boundingBox.fill        = false;
                this.boundingBox.fillColor   = "red";
                this.boundingBox.fillOpacity = 1.0;
                this.boundingBox.x           = xMin - boundingBoxPadding;
                this.boundingBox.y           = yMin - boundingBoxPadding;
                this.boundingBox.width       = xMax - xMin + 2 * boundingBoxPadding;
                this.boundingBox.height      = yMax - yMin + 2 * boundingBoxPadding;
                this.boundingBox.rotation    = 0;
            }
            drawBoundingBox()
            {
                this.boundingBox.handles = [];
                this.boundingBox.draw();
            }
            select(x, y)
            {
                return(this.boundingBox.select(x, y));
            }
            move(dx, dy)
            {
                for(let i = 0; i < this.shapes.length; i++)
                {
                    this.shapes[i].move(dx, dy);
                }
                this.createBoundingBox();
            }
            clear()
            {
                this.shapes = [];
            }
            restore(group_JSON)
            {
                this.type   = group_JSON.type;
                this.id     = group_JSON.id;
                this.zIndex = group_JSON.zIndex;
                for(let j = 0; j < group_JSON.shapes.length; j++)
                {
                    for(let k = 0; k < shapes.length; k++)
                    {
                        if(shapes[k].type == group_JSON.shapes[j].type && 
                           shapes[k].id   == group_JSON.shapes[j].id)
                        {
                            this.shapes.push(shapes[k]);
                        }
                    }
                }
                this.createBoundingBox();
            }
        }
        
        // setup global object arrays
        let shapes      = [];
        let shapeGroups = [];
        let backgrounds = [];

        // plant variables
        let activePlant = null;
        let selectPlantCtx = false;

        // grouping variables
        let nextGroupID     = 0;
        let wipGroupFlag    = false;
        let wipGroup        = new ShapeGroup(nextGroupID, nextZIndex);
        let activeGroupFlag = false;
        let activeGroup     = null;
        
        // keep track of our panning and zooming
        let viewportTransform = { x : 0, y : 0, scale : 1 }

        // Set drawing parameters for landscape border
        const xPlot     = 3600; // 300 ft at 12 px per foot
        const yPlot     = 2400; // 200 ft at 12 px per foot
        const extBorder =  120; //  10 ft exterior plot border in pixels

        // restore the canvas from the server db
        restore();

        //************************************************************//
        // Connect javascript to the level 1 menu items
        //************************************************************//
        // setup the garden planner action
        const actionID = document.getElementById("id_action");
	    actionID.addEventListener("change", (e) =>
        {
            action = actionID.value;
            //
            if (action == 'select')
            {
                id_plant_div.style.display            = 'none';
                id_shape_div.style.display            = 'none';
                id_line_width_div.style.display       = 'none';
                id_line_style_div.style.display       = 'none';
                id_line_color_div.style.display       = 'none';
                id_line_opacity_sel_div.style.display = 'none';
                id_fill_div.style.display             = 'none';
                id_fill_color_div.style.display       = 'none';
                id_fill_opacity_sel_div.style.display = 'none';
                id_opacity_slider_div.style.display   = 'none';
                id_view_layer_div.style.display       = 'inline';
                id_draw_layer_div.style.display       = 'none';
                id_zoom_select_div.style.display      = 'none';
                id_zoom_slider_div.style.display      = 'none';
                id_shape_attributes.style.display     = 'none';
            }
            else if(action == 'add plant')
            {
                id_plant_div.style.display            = 'inline';
                id_shape_div.style.display            = 'none';
                id_line_width_div.style.display       = 'inline';
                id_line_style_div.style.display       = 'inline';
                id_line_color_div.style.display       = 'inline';
                id_line_opacity_sel_div.style.display = 'inline';
                id_fill_div.style.display             = 'inline';
                id_fill_color_div.style.display       = 'inline';
                id_fill_opacity_sel_div.style.display = 'inline';
                id_view_layer_div.style.display       = 'none';
                id_draw_layer_div.style.display       = 'inline';
                id_zoom_select_div.style.display      = 'none';
                id_zoom_slider_div.style.display      = 'none';
                id_shape_attributes.style.display     = 'none';
            }
            else if(action == 'draw')
            {
                id_plant_div.style.display            = 'none';
                id_shape_div.style.display            = 'inline';
                id_line_width_div.style.display       = 'inline';
                id_line_style_div.style.display       = 'inline';
                id_line_color_div.style.display       = 'inline';
                id_line_opacity_sel_div.style.display = 'inline';
                if (shapeOption.value == "rectangle" || 
                    shapeOption.value == "circle"    || 
                    shapeOption.value == "ellipse"   || 
                    shapeOption.value == "polygon")
                {
                    id_fill_div.style.display             = 'inline';
                    id_fill_color_div.style.display       = 'inline';
                    id_fill_opacity_sel_div.style.display = 'inline';
                    id_opacity_slider_div.style.display   = 'inline-block';
                }
                id_view_layer_div.style.display   = 'none';
                id_draw_layer_div.style.display   = 'inline';
                id_zoom_select_div.style.display  = 'none';
                id_zoom_slider_div.style.display  = 'none';
                id_shape_attributes.style.display = 'none';
                unGroup.style.display = "none";

                activeGroupFlag = false;
                activeGroup = null;

                drawScreen();
            }
            else if(action == 'pan')
            {
                id_plant_div.style.display            = 'none';
                id_shape_div.style.display            = 'none';
                id_line_width_div.style.display       = 'none';
                id_line_style_div.style.display       = 'none';
                id_line_color_div.style.display       = 'none';
                id_line_opacity_sel_div.style.display = 'none';
                id_fill_div.style.display             = 'none';
                id_fill_color_div.style.display       = 'none';
                id_fill_opacity_sel_div.style.display = 'none';
                id_opacity_slider_div.style.display   = 'none';
                id_view_layer_div.style.display       = 'none';
                id_draw_layer_div.style.display       = 'none';
                id_zoom_select_div.style.display      = 'none';
                id_zoom_slider_div.style.display      = 'none';
                id_shape_attributes.style.display     = 'none';
            }
            else if(action == 'zoom')
            {
                id_plant_div.style.display            = 'none';
                id_shape_div.style.display            = 'none';
                id_line_width_div.style.display       = 'none';
                id_line_style_div.style.display       = 'none';
                id_line_color_div.style.display       = 'none';
                id_line_opacity_sel_div.style.display = 'none';
                id_fill_div.style.display             = 'none';
                id_fill_color_div.style.display       = 'none';
                id_fill_opacity_sel_div.style.display = 'none';
                id_opacity_slider_div.style.display   = 'none';
                id_view_layer_div.style.display       = 'none';
                id_draw_layer_div.style.display       = 'none';
                id_zoom_select_div.style.display      = 'inline';
                id_zoom_slider_div.style.display      = 'inline-block';
                id_shape_attributes.style.display     = 'none';
            }
        });

        // Group/Ungroup buttons
        const makeGroup = document.getElementById('id_group_div');
        const unGroup   = document.getElementById('id_ungroup_div');
        //************************************************************//
        // Connect javascript to the level 2 menu items
        //************************************************************//
        // Setup layer selections
        let layer = document.getElementById("id_layer_div");
        
        // Retrieve the selected plant from the server db
        let requestedPlant = document.getElementById("id_plant");
        requestedPlant.addEventListener("change", (e) =>
        {
            // create the new plant object
            const newPlant = new Plant(requestedPlant.value,   // plant to be fetched from server
                                       "plant",                // type of object
                                       nextPlantID,            // id
                                       false,                  // grouped flag
                                       "plant",                // label for drawn shape
                                       layer,                  // layer there the plant resides
                                       nextZIndex,             // z index for plant
                                       "circle",               // type of shape representing plant
                                       lineWidthInput.value, 
                                       lineStyleInput.value, 
                                       lineColorInput.value,
                                       lineOpacityInput.value,
                                       fillCheckbox.value, 
                                       fillColorInput.value, 
                                       "fillPattern",
                                       fillOpacityInput.value);
            // add plant to shapes array and get details from server
            shapes.push(newPlant);
            nextPlantID++;
            shapes[shapes.length - 1].fetchDetails();
            // Reset the type of plant to be added - this is necessary to immediately add the same plant 
            requestedPlant.value = "--";           
        });

        // Setup the shape to be drawn
        const shapeOption      = document.getElementById("id_shape");
        const lineWidthInput   = document.getElementById("id_line_width");
        const lineStyleInput   = document.getElementById("id_line_style");
        const lineColorInput   = document.getElementById("id_line_color");
        const lineOpacityInput = document.getElementById("id_line_opacity_sel");
        const fillCheckbox     = document.getElementById("id_fill");
        const fillColorInput   = document.getElementById("id_fill_color");
        const fillOpacityInput = document.getElementById("id_fill_opacity_sel");
        const drawLayerInput   = document.getElementsByName("draw_layer");

        const viewLayerAll         = document.getElementById("view_layer_all");
        const viewLayerGround      = document.getElementById("view_layer_ground");
        const viewLayerGroundcover = document.getElementById("view_layer_groundcover");
        const viewLayerFlower      = document.getElementById("view_layer_flower");
        const viewLayerShrub       = document.getElementById("view_layer_shrub");
        const viewLayerSmallTree   = document.getElementById("view_layer_small_tree");
        const viewLayerLargeTree   = document.getElementById("view_layer_large_tree");

        // Setup layers to display
        const viewLayerInput   = document.getElementsByName("view_layer");
        
        // actions to be take when menu items are changed
        shapeOption.addEventListener("change", (e) =>
        {
            if (shapeOption.value == "line" || shapeOption.value == "curve")
            {
                id_fill_div.style.display             = 'none';
                id_fill_color_div.style.display       = 'none';
                id_fill_opacity_sel_div.style.display = 'none';
            }
            else if (shapeOption.value == "rectangle" || shapeOption.value == "circle" || 
                     shapeOption.value == "ellipse"   || shapeOption.value == "polygon")
            {
                id_fill_div.style.display = 'inline';
            }
        });
        fillCheckbox.addEventListener('change', (e) =>  
        {
            if(fillCheckbox.checked)
            {
                id_fill_color_div.style.display       = 'inline';
                id_fill_opacity_sel_div.style.display = 'inline';
            }
            else
            {
                id_fill_color_div.style.display       = 'none';
                id_fill_opacity_sel_div.style.display = 'none';
            }
        });

        viewLayerAll.addEventListener('change', (e) =>
        {
            if (viewLayerAll.checked)
            {
                viewLayerGround.checked      = false;
                viewLayerGroundcover.checked = false;
                viewLayerFlower.checked      = false;
                viewLayerShrub.checked       = false;
                viewLayerSmallTree.checked   = false;
                viewLayerLargeTree.checked   = false;
            }
            drawScreen();
        });
        viewLayerGround.addEventListener('change', (e) =>
        {
            if (viewLayerGround.checked)
            {
                viewLayerAll.checked = false;
            }
            drawScreen();
        });
        viewLayerGroundcover.addEventListener('change', (e) =>
        {
            if (viewLayerGroundcover.checked)
            {
                viewLayerAll.checked = false;
            }
            drawScreen();
        });
        viewLayerFlower.addEventListener('change', (e) =>
        {
            if (viewLayerFlower.checked)
            {
                viewLayerAll.checked = false;
            }
            drawScreen();
        });
        viewLayerShrub.addEventListener('change', (e) =>
        {
            if (viewLayerShrub.checked)
            {
                viewLayerAll.checked = false;
            }
            drawScreen();
        });
        viewLayerSmallTree.addEventListener('change', (e) =>
        {
            if (viewLayerSmallTree.checked)
            {
                viewLayerAll.checked = false;
            }
            drawScreen();
        });
        viewLayerLargeTree.addEventListener('change', (e) =>
        {
            if (viewLayerLargeTree.checked)
            {
                viewLayerAll.checked = false;
            }
            drawScreen();
        });

        // Setup the zoom select
        zoomSelect = document.getElementById("id_zoom_select");
        zoomSelect.addEventListener('change', (e) =>
        {
            const xScale = canvas.width  / (xPlot - (3 * extBorder));
            const yScale = canvas.height / (yPlot);
            const scale  = Math.min(xScale, yScale);

            if(zoomSelect.value == "100%")
            {    
                viewportTransform.scale = xScale * 1.0;
                viewportTransform.x = 0;
                viewportTransform.y = 0;
            }
            else if(zoomSelect.value == "200%")
            {
                viewportTransform.scale = xScale * 2.0;
            }
            else if(zoomSelect.value == "300%")
            {
                viewportTransform.scale = xScale * 3.0;
            }
            else if(zoomSelect.value == "400%")
            {
                viewportTransform.scale = xScale * 4.0;
            }
            else if(zoomSelect.value == "500%")
            {
                viewportTransform.scale = xScale * 5.0;
            }

            drawScreen();
        });

        // Setup the zoom slider
        zoomSlider = document.getElementById("id_zoom_slider");
        zoomSlider.addEventListener('input', (e) =>
        {
            // reset the zoom select to slider mode
            zoomSelect.value = "Slider";
            // determine the xScale at 100% zoom
            const xScale = canvas.width  / (xPlot - (3 * extBorder));
            // scale the canvas based upon the slider value
            viewportTransform.scale = xScale * (zoomSlider.value / 100);

            drawScreen();
        });
        
        //************************************************************//
        // Get the HTML element which will display the attribues for the selected shape
        //************************************************************//
        let shapeAttributes = document.getElementById("id_shape_attributes");

        drawScreen();

        // When the window is resized, adjust canvas size to fit
        window.addEventListener("resize", function()
        {
            canvas.width  = window.innerWidth  -  40;
            canvas.height = window.innerHeight - 300;
            drawScreen();
        });

        //************************************************************//
        // mouse click events
        //************************************************************//
        canvas.addEventListener("click", (e) => 
        {
            console.log("DEBUG: *** Mouse click event registered ***");

            // canvas selection point - absolute position
            xSelectAbs = (e.clientX - canvas.offsetLeft - viewportTransform.x) / viewportTransform.scale ;
            ySelectAbs = (e.clientY - canvas.offsetTop  - viewportTransform.y) / viewportTransform.scale ;

            if (action == "select")
            {
                // Disable the mousedown, mousemove, & mouseup events
                createShape = false;
                // Case: single shape selection
                // - if a shape was previously selected it will be deselected
                if(!e.shiftKey)
                {
                    // clear object selections and shape/group arrays
                    selectShape     = false;
                    activeShape     = null;
                    wipGroupFlag    = false;
                    wipGroup.clear();
                    activeGroupFlag = false;
                    activeGroup     = null;

                    // Go through each shape to see if it has been selected
                    for (let i = 0; i < shapes.length; i++) 
                    {
                        // clear the shapes handles
                        shapes[i].clearHandles();
                        // check to see if the shape has been selected
                        if(shapes[i].select(xSelectAbs, ySelectAbs))
                        { 
                            activeShape = shapes[i];
                            // Case: selected shape check is not currently a member of a group
                            if(!activeShape.grouped)
                            {
                                // Indicate that the modify shape mode is enabled for the selected shape
                                selectShape = true;
                                // at this point it is a group of 1
                                wipGroup.addShape(shapes[i]);
                            }
                            // Case: selected shape is currently a member of a group
                            else
                            {
                                // determine the group which the shape is a member of
                                for(let i = 0; i < shapeGroups.length; i++)
                                {
                                    for(let j = 0; j < shapeGroups[i].shapes.length; j++)
                                    {
                                        if(activeShape.id == shapeGroups[i].shapes[j].id)
                                        {
                                            // set the activeGroup
                                            activeGroupFlag = true;
                                            activeGroup     = shapeGroups[i];
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                // Case: additional shapes being selected - shape(s) already selected
                else if (selectShape && e.shiftKey)
                {
                    // Go through each shape to see if it has been selected
                    // Previously selected shapes will remain selected (handles visible)
                    for (let i = 0; i < shapes.length; i++) 
                    {
                        if(shapes[i].select(xSelectAbs, ySelectAbs))
                        {
                            // put shape in WIP group object shape array and show 'group' button
                            wipGroupFlag = true;
                            wipGroup.addShape(shapes[i]);
                        }
                    }
                }
   
                // If a shape is selected, display the shape attributes
                if (selectShape)
                {
                    shapeAttributes.innerHTML = activeShape.showAttributes();
                    shapeAttributes.style.display = "inline";
                }
                // No shape was selected: clear selection attributes and the canvas display
                else
                { 
                    createShape = false;
                    activeShape = null;
                    wipGroupFlag = false;
                    wipGroup.clear(); 
                    shapeAttributes.style.display = "none";  
                }

                if(wipGroupFlag)
                {
                    makeGroup.style.display       = "inline";
                    unGroup.style.display         = "none";
                    shapeAttributes.style.display = "none";
                }
                else
                {
                    makeGroup.style.display = "none";
                }

                // If a group has been selected
                if (activeGroup)
                {
                    makeGroup.style.display = "none";
                    unGroup.style.display   = "inline";
                }
                else
                {
                    unGroup.style.display = "none";
                }
                
                // Draw the entire screen
                drawScreen();
            }
        });

        //************************************************************//
        // mouse down events - dependent on selected action and shape
        //************************************************************//
        canvas.addEventListener("mousedown", (e) => 
        {
            // Return if we are not in a mouse down/move/up mode
            if (action != "select" && action != "draw" && action != "add plant" && action != "pan")
            {
                return;
            } 

            console.log("DEBUG: *** Mouse down event registered ***");

            // Defiitions:
            //   e.clientX = horizontal coordinate at which a mouse event occurred, 
            //               relative to the viewport's left edge
            //   e.clientY = verticle coordinate at which a mouse event occurred, 
            //               relative to the viewport's top edge
            //
            //   canvas.offsetLeft = canvas's left offset
            //   canvas.offsetTop  = canvas's top offset

            // Canvas selection point - relative position
            xSelectRel = Math.round(e.clientX - canvas.offsetLeft);
            ySelectRel = Math.round(e.clientY - canvas.offsetTop );

            // Canvas selection point - absolute position
            xSelectAbs = Math.round((e.clientX - canvas.offsetLeft - viewportTransform.x) / viewportTransform.scale);
            ySelectAbs = Math.round((e.clientY - canvas.offsetTop  - viewportTransform.y) / viewportTransform.scale);

            // Draw a new shape
            if (action == "draw")
            {
                createShape = true;
                let drawingLayer = "ground";
                let fill  = false;
                if(fillCheckbox.checked)
                {
                    fill = true;
                }

                for (i = 0; i < drawLayerInput.length; i++) 
                {
                    if (drawLayerInput[i].checked)
                    {
                        drawingLayer = drawLayerInput[i].value;
                    }
                }

                if (shapeOption.value == "line")
                {
                    activeShape = new Line('line', 
                                           nextShapeID, 
                                           false, 
                                           'line', 
                                           drawingLayer, 
                                           nextZIndex,
                                           lineWidthInput.value, 
                                           lineStyleInput.value, 
                                           lineColorInput.value, 
                                           lineOpacityInput.value,
                                           fillCheckbox.value, 
                                           fillColorInput.value, 
                                           "fillPattern",
                                           fillOpacityInput.value,
                                           xSelectAbs,                  // x starting point
                                           ySelectAbs,                  // y starting point point
                                           xSelectAbs,                  // x ending point
                                           ySelectAbs);                 // y ending point
                    nextShapeID++;
                    nextZIndex++;
                }
                else if (shapeOption.value == "curve")
                {
                    activeShape = new Curve('curve', 
                                            nextShapeID, 
                                            false, 
                                            'curve', 
                                            drawingLayer, 
                                            nextZIndex,
                                            lineWidthInput.value, 
                                            lineStyleInput.value, 
                                            lineColorInput.value, 
                                            lineOpacityInput.value,
                                            fillCheckbox.value, 
                                            fillColorInput.value, 
                                            "fillPattern", 
                                            fillOpacityInput.value,
                                            xSelectAbs,                 // x starting point
                                            ySelectAbs,                 // y starting point
                                            xSelectAbs,                 // x control point
                                            ySelectAbs,                 // y control point
                                            xSelectAbs,                 // x ending point
                                            ySelectAbs);                // y ending point
                    nextShapeID++;
                    nextZIndex++;
                }
                else if (shapeOption.value == "rectangle")
                {
                    activeShape = new Rectangle('rectangle', 
                                                nextShapeID, 
                                                false, 
                                                'rectangle', 
                                                drawingLayer, 
                                                nextZIndex,
                                                lineWidthInput.value, 
                                                lineStyleInput.value, 
                                                lineColorInput.value,
                                                lineOpacityInput.value, 
                                                fillCheckbox.value, 
                                                fillColorInput.value, 
                                                "fillPattern", 
                                                fillOpacityInput.value,
                                                xSelectAbs,             // x origin
                                                ySelectAbs,             // y origin
                                                0,                      // width
                                                0,                      // height
                                                0);                     // rotation
                    nextShapeID++;
                    nextZIndex++;
                }
                else if (shapeOption.value == "circle")
                {
                    activeShape = new Circle('circle', 
                                             nextShapeID, 
                                             false, 
                                             'circle', 
                                             drawingLayer, 
                                             nextZIndex,
                                             lineWidthInput.value, 
                                             lineStyleInput.value, 
                                             lineColorInput.value,
                                             lineOpacityInput.value, 
                                             fillCheckbox.value, 
                                             fillColorInput.value, 
                                             "fillPattern", 
                                             fillOpacityInput.value,
                                             xSelectAbs,                // x center
                                             ySelectAbs,                // y center
                                             0);                        // radius
                    nextShapeID++;
                    nextZIndex++;
                }
                else if (shapeOption.value == "ellipse")
                {
                    activeShape = new Ellipse('ellipse', 
                                             nextShapeID, 
                                             false, 
                                             'ellipse', 
                                             drawingLayer, 
                                             nextZIndex,
                                             lineWidthInput.value, 
                                             lineStyleInput.value, 
                                             lineColorInput.value,
                                             lineOpacityInput.value, 
                                             fillCheckbox.value, 
                                             fillColorInput.value, 
                                             "fillPattern", 
                                             fillOpacityInput.value,
                                             xSelectAbs,                // x center
                                             ySelectAbs,                // y center
                                             0,                         // x radius
                                             0,                         // y radius
                                             0);                        // rotation
                    nextShapeID++;
                    nextZIndex++;
                }
                else if (shapeOption.value == "polygon")
                {
                    if (polygonWIP == false)
                    {
                        // Create polygon object
                        activeShape = new Polygon('polygon', 
                                                  nextShapeID, 
                                                  false, 
                                                  'polygon', 
                                                  drawingLayer, 
                                                  nextZIndex,
                                                  lineWidthInput.value, 
                                                  lineStyleInput.value, 
                                                  lineColorInput.value,
                                                  lineOpacityInput.value, 
                                                  fillCheckbox.value, 
                                                  fillColorInput.value, 
                                                  "fillPattern", 
                                                  fillOpacityInput.value,
                                                  [], 
                                                  0, 
                                                  status);

                        // Set polygon starting point
                        activeShape.vertices.push({ x : xSelectAbs, y : ySelectAbs });

                        // Polygon drawing in process
                        polygonWIP  = true;
                        nextShapeID++;
                        nextZIndex++;
                    }
                    // set the starting coordinates for the next point
                    activeShape.xPolygonVertex = xSelectAbs;
                    activeShape.yPolygonVertex = ySelectAbs;
                    activeShape.vertices.push({ x : xSelectAbs, y : ySelectAbs });
                    if(e.shiftKey)
                    {
                        polygonCurve = true;
                    }
                    else
                    {
                        polygonCurve = false;
                    }
                }

                xSelectAbsSave = xSelectAbs;
                ySelectAbsSave = ySelectAbs;

                // display shape attributes text
                id_shape_attributes.style.display = 'inline';
            }
            // Move or resize selected shape
            else if (action == 'select' && selectShape && activeShape)
            {
                // save the selection point for future use
                xSelectAbsSave = xSelectAbs;
                ySelectAbsSave = ySelectAbs;

                // check to see if a handle has been selected
                activeHandle = activeShape.selectHandle(xSelectAbs, ySelectAbs);
                
                if(activeHandle && activeHandle.location != 'rotate')
                {
                    // Indicate that shape is in 'resize' mode
                    resizeShape = true;
                    // set the selection point to the center of the handle
                    xSelectAbsSave = activeHandle.x;
                    ySelectAbsSave = activeHandle.y;
                }
                else if(activeHandle && activeHandle.location == 'rotate')
                {
                    // Indicate that shape is in 'rotate' mode
                    rotateShape = true;
                    // set the selection point to the center of the handle
                    xSelectAbsSave = activeHandle.x;
                    ySelectAbsSave = activeHandle.y;
                }
                // If no handle of the active shape was selected check to see if the
                // body of the active shape was selected
                else if(activeShape.select(xSelectAbs, ySelectAbs))
                {
                    moveShape = true;
                }
            }
            // Move selected group
            else if (action == 'select' && activeGroup)
            {
                if(activeGroup.select(xSelectAbs, ySelectAbs))
                {
                    moveGroup = true;
                    // save the selection point for future use
                    xSelectAbsSave = xSelectAbs;
                    ySelectAbsSave = ySelectAbs;
                }
            }
            // Begin panning
            else if (action == 'pan')
            {
                panning = true;
                xSelectRelSav = xSelectRel;
                ySelectRelSav = ySelectRel;
            } 
            // Draw the entire screen
            drawScreen();
        });

        //************************************************************//
        // mouse move events - dependent on selected action and shape
        //************************************************************//
        canvas.addEventListener("mousemove", (e) => 
        {
            // Return if we are not in a mouse down/move/up mode
            if (!createShape && !resizeShape && !rotateShape && !moveShape && !panning && !moveGroup)
            {
                return;
            } 

            console.log("DEBUG: *** Mouse move event registered ***");

            // get current mouse location (relative to viewport)
            xMouse = e.clientX - canvas.offsetLeft;
            yMouse = e.clientY - canvas.offsetTop;

            // get current mouse location (absolute)
            xMouseAbs = (e.clientX - canvas.offsetLeft - viewportTransform.x) / viewportTransform.scale;
            yMouseAbs = (e.clientY - canvas.offsetTop  - viewportTransform.y) / viewportTransform.scale;

            // determine how much mouse has moved
            // initial xSelectAbsSave & ySelectAbsSave were set via mousedown event
            xDelta = Math.round(xMouseAbs - xSelectAbsSave);
            yDelta = Math.round(yMouseAbs - ySelectAbsSave);

            // Draw the active shape
            if (action == "draw")
            { 
                activeShape.createShape(xDelta, yDelta);
            }     
            // Move the selected shape
            else if(action == 'select' && moveShape)
            {
                activeShape.move(xDelta, yDelta);
            }        
            // Resize the selected shape
            else if (action == 'select' && resizeShape)
            {
                activeShape.resize(activeHandle, xDelta, yDelta);
            }
            // Rotate the selected shape
            else if (action == 'select' && rotateShape && activeShape.type == "rectangle")
            {
                activeShape.rotate(xDelta, yDelta);
            }
            // Move the select group
            else if (action == 'select' && moveGroup)
            {
                activeGroup.move(xDelta, yDelta);
            }
            // Pan
            else if (panning)
            {
                xDelta = xMouse - xSelectRelSav;
                yDelta = yMouse - ySelectRelSav;

                viewportTransform.x += xDelta;
                viewportTransform.y += yDelta;
            }

            // save the current mouse location - relative
            xSelectRelSav = xMouse;
            ySelectRelSav = yMouse;

            //save the current mouse location - absolute
            xSelectAbsSave += xDelta;
            ySelectAbsSave += yDelta;

            // Update the shape attributes
            if (action == 'draw' || action == 'select' && !moveGroup)
            {
                shapeAttributes.innerHTML = activeShape.showAttributes();
            }

            // Draw the entire screen
            drawScreen();
        });

        //************************************************************//
        // mouse up events - dependent on selected action and shape
        //************************************************************//
        canvas.addEventListener("mouseup", (e) => 
        {
            // Return if we are not in a mouse down/move/up mode
            if (!createShape && !resizeShape && !rotateShape && !moveShape && !panning && !moveGroup)
            {
                return;
            } 

            console.log("DEBUG: *** Mouse up event registered ***");
            
            if (action == "draw")
            {
                activeShape.createShapeEnd(xMouse, yMouse);
                id_shape_attributes.style.display = 'none';
            }
            // Draw the entire screen
            drawScreen();

            // reset the current shape and flags
            createShape = false;
            resizeShape = false;
            rotateShape = false;
            moveShape   = false;
            moveGroup   = false;
            selectShape = false;
            panning     = false;
            xDeltaAcc   = 0;
            yDeltaAcc   = 0;
        });

        //************************************************************//
        // mouse out events - dependent on selected action and shape
        //************************************************************//
        canvas.addEventListener("mouseout", (e) => 
        {
            // Return if we are not in a mouse down/move/up mode
            if (!createShape && !resizeShape && !rotateShape && !moveShape && !panning)
            {
                return;
            } 

            console.log("DEBUG: *** Mouse out event registered ***");
        
            // reset the current shape and flags
            activeShape = null;
            createShape = false;
            resizeShape = false;
            rotateShape = false;
            moveShape   = false;
            selectShape = false;
            panning     = false;

            // Draw the entire screen
            drawScreen();
        });

        //************************************************************//
        // mouse right click (context menu) events
        //************************************************************//
        // get edit form fields
        const labelForm     = document.getElementById('labelForm');
        // line and curve coordinates
        const xStartFtForm  = document.getElementById('xStartFtForm');
        const xStartInForm  = document.getElementById('xStartInForm');
        const yStartFtForm  = document.getElementById('yStartFtForm');
        const yStartInForm  = document.getElementById('yStartInForm');
        const xEndFtForm    = document.getElementById('xEndFtForm');
        const xEndInForm    = document.getElementById('xEndInForm');
        const yEndFtForm    = document.getElementById('yEndFtForm');
        const yEndInForm    = document.getElementById('yEndInForm');
        // curve coordinates
        const xControlFtForm = document.getElementById('xControlFtForm');
        const xControlInForm = document.getElementById('xControlInForm');
        const yControlFtForm = document.getElementById('yControlFtForm');
        const yControlInForm = document.getElementById('yControlInForm');
        // rectangle coordinates
        const xFtForm        = document.getElementById('xFtForm');
        const xInForm        = document.getElementById('xInForm');
        const yFtForm        = document.getElementById('yFtForm');
        const yInForm        = document.getElementById('yInForm');
        // circle and ellipse coordinates
        const xCenterFtForm  = document.getElementById('xCenterFtForm');
        const xCenterInForm  = document.getElementById('xCenterInForm');
        const yCenterFtForm  = document.getElementById('yCenterFtForm');
        const yCenterInForm  = document.getElementById('yCenterInForm');
        // polygon coordinates
        const polygonHTML    = document.getElementById('polygonHTML');
        //
        const widthFtForm    = document.getElementById('widthFtForm');
        const widthInForm    = document.getElementById('widthInForm');
        const heightFtForm   = document.getElementById('heightFtForm');
        const heightInForm   = document.getElementById('heightInForm');
        //
        const radiusFtForm   = document.getElementById('radiusFtForm');
        const radiusInForm   = document.getElementById('radiusInForm');
        //
        const xRadiusFtForm  = document.getElementById('xRadiusFtForm');
        const xRadiusInForm  = document.getElementById('xRadiusInForm');
        const yRadiusFtForm  = document.getElementById('yRadiusFtForm');
        const yRadiusInForm  = document.getElementById('yRadiusInForm');
        //
        const rotationForm   = document.getElementById('rotationForm');
        //
        const lineWidthForm   = document.getElementById('lineWidthForm');
        const lineStyleForm   = document.getElementById('lineStyleForm');
        const lineColorForm   = document.getElementById('lineColorForm');
        const lineOpacityForm = document.getElementById('lineOpacityForm');
        //
        const fillColorForm   = document.getElementById('fillColorForm');
        const fillOpacityForm = document.getElementById('fillOpacityForm');
        // used to create specific context edit menus for each shape type
        const line      = document.getElementsByClassName('line');
        const curve     = document.getElementsByClassName('curve');
        const rectangle = document.getElementsByClassName('rectangle');
        const circle    = document.getElementsByClassName('circle');
        const ellipse   = document.getElementsByClassName('ellipse');
        const polygon   = document.getElementsByClassName('polygon');
        // selected shape's index in the shape array
        let shapeIndex;

        // Context menu: Open the context menu
        canvas.addEventListener("contextmenu", (e) => 
        {
            console.log("DEBUG: *** Mouse right click event registered ***");

            // Prevent default browser context menu
            e.preventDefault()

            // Get mouse position - relative to canvas
            xSelectRel = e.clientX - canvas.offsetLeft;
            ySelectRel = e.clientY - canvas.offsetTop;

            // Get mouse position - absolute position
            xSelectAbs = (e.clientX - canvas.offsetLeft - viewportTransform.x) / viewportTransform.scale ;
            ySelectAbs = (e.clientY - canvas.offsetTop  - viewportTransform.y) / viewportTransform.scale ;

            xSelectAbsSave = xSelectAbs;
            ySelectAbsSave = ySelectAbs;
            selectPlantCtx = false;
            selectShapeCtx = false;

            // Check to see if a plant or shape has been selected
            for (let i = 0; i < shapes.length; i++) 
            {
                if (shapes[i].type == "plant")
                {
                    // Check to see if the selection point is within the plant
                    if(shapes[i].select(xSelectAbs, ySelectAbs))
                    {
                        selectPlantCtx = true;
                        shapeIndex = i;
                    }
                }
                else
                {
                    // Determine the shape has been selected.  If so, duplicate the shape
                    if(shapes[i].select(xSelectAbs, ySelectAbs))
                    {
                        selectShapeCtx = true;
                        shapeIndex = i;
                    }
                }
            }

            // Position and show the custom menu
            if(selectPlantCtx)
            {
                ctxPlantMenu.style.left = xSelectRel + 'px';
                ctxPlantMenu.style.top  = (ySelectRel + 140) + 'px';
                ctxPlantMenu.style.display = 'block';
                ctxShapeMenu.style.display = 'none';
            }
            else if (selectShapeCtx)
            {
                ctxShapeMenu.style.left = xSelectRel + 'px';
                ctxShapeMenu.style.top  = (ySelectRel + 140) + 'px';
                ctxShapeMenu.style.display = 'block';
                ctxPlantMenu.style.display = 'none';
            }
        });

        // Context menu: Hide context menu when clicking outside of it
        document.addEventListener('click', function(e) 
        {
            if (!ctxPlantMenu.contains(e.target) && !ctxShapeMenu.contains(e.target))
            {
                ctxPlantMenu.style.display = 'none';
                ctxShapeMenu.style.display = 'none';
                // cleanup
                selectPlantCtx = false;
                selectShapeCtx = false;
            }
        });

        // Context menu: Add click handlers for plant menu items
        ctxPlantMenu.addEventListener('click', function(e) 
        {
            if (selectPlantCtx == true && e.target.tagName === 'DIV') 
            {
                if (e.target.textContent == "Plant: Show Details")
                {
                    shapes[shapeIndex].getModal();
                }
                else if (e.target.textContent == "Plant: Duplicate")
                {
                    // make a deep copy of selected plant and shift new object origin to make it visible
                    duplicatePlant = shapes[shapeIndex].duplicate(nextPlantID);
                    nextPlantID++;
                    drawScreen();
                }
                else if (e.target.textContent == "Plant: Delete")
                {
                    shapes.splice(shapeIndex, 1);
                }
                // Hide menu after action
                ctxPlantMenu.style.display = 'none'; 
            }
            // cleanup
            selectShapeCtx = false;
            // Draw the entire screen
            drawScreen();
        });

        // Context menu: Add click handlers for shape menu items
        ctxShapeMenu.addEventListener('click', function(e) 
        {
            if (selectShapeCtx == true && e.target.tagName === 'DIV') 
            {
                if (e.target.textContent == "Shape: Edit")
                {
                    // display the shape edit model
                    planner_edit_modal.style.display = 'block';
                    // set up the edit menu for the selected shape
                    shapes[shapeIndex].editMenu();
                }
                else if (e.target.textContent == "Shape: Duplicate")
                {
                    duplicateShape = shapes[shapeIndex].duplicate(nextShapeID);
                    nextShapeID++;
                    nextZIndex++;
                    shapes.push(duplicateShape); 
                }
                else if (e.target.textContent == "Shape: Delete")
                {
                    shapes.splice(shapeIndex, 1);
                }
                else if (e.target.textContent == "Shape: To Front")
                {
                    shapes[shapeIndex].toFront(nextZIndex);
                    nextZIndex++;
                    zIndexSort();
                }
                // Hide menu after action
                ctxShapeMenu.style.display = 'none'; 
            }
            // cleanup
            selectShapeCtx = false;
            // Draw the entire screen
            drawScreen();
        });

        // function to process the user's inputs from the attribute edit form
        const editForm = document.getElementById('id_edit_form');
        editForm.addEventListener('submit', function(e)
        {
            // This line prevents the default form submission (page reload)
            e.preventDefault(); 
            // update the shape per the edit menu inputs
            shapes[shapeIndex].editSave();
            // hide the modal
            planner_edit_modal.style.display = 'none';
            // Draw the entire screen
            drawScreen();
        });

        //************************************************************//
        // mouse wheel events - zoom
        //************************************************************//
        canvas.addEventListener("mousewheel", (e) => 
        {
            // Return if we are not in zoom mode
            if (action != "zoom")
            {
                return;
            } 

            console.log("DEBUG: *** Mouse wheel event registered ***");

            // Save the previous transforms and scale factor
            const previousScale = viewportTransform.scale;
            const previousX     = viewportTransform.x;
            const previousY     = viewportTransform.y;

            // limit the zoom factors
            const zoomMin = 0.45;
            const zoomMax = 5.00;

            // capture the current mouse location 
            xMouse = e.clientX;
            yMouse = e.clientY;

            const newScale = viewportTransform.scale + (e.deltaY * -0.01);

            if(newScale >= zoomMin && newScale <= zoomMax)
            {
                // set the new scale factor
                viewportTransform.scale = newScale;

                // set the new transformation coordinates in order to ...
                viewportTransform.x = xMouse - (xMouse - previousX) * (newScale / previousScale);
                viewportTransform.y = yMouse - (yMouse - previousY) * (newScale / previousScale);
            }

            // Draw the entire screen
            drawScreen()
        });

        //************************************************************//
        // Function: Group the selected shapes and create bounding box
        //************************************************************//
        const group = document.getElementById("id_group");
        group.onclick = (event) => 
        {
            console.log("DEBUG: *** Grouping Shapes ***");
            // give a numerical value to each layer
            const layerGround      = 1;
            const layerGroundcover = 2;
            const layerFlower      = 3;
            const layerShrub       = 4;
            const layerSmallTree   = 5;
            const layerLargeTree   = 6;
            const layerAll         = 7;
            // set the default layer
            let highestLayer       = 1;

            // set the group flag for the shapes that are in the group
            // find the highest layer of the shapes in the group
            for(let i = 0; i < wipGroup.shapes.length; i++)
            {
                wipGroup.shapes[i].grouped = true;

                if (wipGroup.shapes[i].layer == "ground" && highestLayer == 1)
                {
                    highestLayer = 1;
                    layer = "ground";
                }
                else if(wipGroup.shapes[i].layer == "groundcover" && highestLayer < 2)
                {
                    highestLayer = 2;
                    layer = "groundcover";
                }
                else if(wipGroup.shapes[i].layer == "flower" && highestLayer < 3)
                {
                    highestLayer = 3;
                    layer = "flower";
                }
                else if(wipGroup.shapes[i].layer == "shrub" && highestLayer < 4)
                {
                    highestLayer = 4;
                    layer = "shrub";
                }
                else if(wipGroup.shapes[i].layer == "small_tree" && highestLayer < 5)
                {
                    highestLayer = 5;
                    layer = "small_tree";
                }
                else if(wipGroup.shapes[i].layer == "large_tree" && highestLayer < 6)
                {
                    highestLayer = 6;
                    layer = "large_tree";
                }
                else if(wipGroup.shapes[i].layer == "all")
                {
                    highestLayer = 7;
                    layer = "all";
                }
            }
            // create the bounding box for the newly created group
            wipGroup.createBoundingBox();

            // make a deep copy of wipGroup and add to shapeGroups
            const deepCopy  = new ShapeGroup(0, nextZIndex, layer);
            deepCopy.type   = "group";
            deepCopy.id     = nextGroupID;
            deepCopy.shapes = wipGroup.shapes;
            deepCopy.createBoundingBox();

            shapeGroups.push(deepCopy);

            // set activeGroup to the newly formed group
            activeGroupFlag = true;
            activeGroup = shapeGroups.at(-1);

            // reset the grouping process
            wipGroupFlag = false;
            wipGroup.clear();
            nextGroupID++;
            activeShape = null;
            selectShape = false;
            makeGroup.style.display = "none";
            unGroup.style.display   = "inline";

            drawScreen();
        }
        
        //************************************************************//
        // Function: Ungroup the shapes in the selected group
        //************************************************************//
        const ungroup = document.getElementById("id_ungroup");
        ungroup.onclick = (event) => 
        {
            // remove the active Group from shapeGroups and set group flag to false for each shape
            for(let i = 0; i < shapeGroups.length; i++)
            {
                if(shapeGroups[i].id == activeGroup.id)
                {
                    for(let j = 0; j < shapeGroups[i].shapes.length; j++)
                    {
                        for(let k = 0; k < shapes.length; k++)
                        {
                            if(shapes[k].id == shapeGroups[i].shapes[j].id)
                            {
                                shapes[k].grouped = false;
                            }
                        }
                    }
                    shapeGroups.splice(i, 1);
                }
            }
            activeGroupFlag = false;
            unGroup.style.display = "none";
            drawScreen();
        }

        //************************************************************//
        // Function: pixels to feet
        //************************************************************//
        function pix2ft(pixels)
        {
            return(Math.trunc(pixels / 12)) + " ft  " + Math.trunc(pixels % 12) + " in";
        }

        //************************************************************//
        // Function: Drag-and-Drop
        //************************************************************//
        //Make the modal (<div> element) draggable:
        dragElement(document.getElementById("plant_details_modal"));
        // dragElement(document.getElementById("planner_edit_modal"));
        function dragElement(elmnt) 
        {
            var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            if (document.getElementById(elmnt.id + "header")) 
            {
                /* if present, the header is where you move the DIV from:*/
                document.getElementById(elmnt.id + "header").onmousedown = dragMouseDown;
            } 
            else 
            {
                /* otherwise, move the DIV from anywhere inside the DIV:*/
                elmnt.onmousedown = dragMouseDown;
            }

            function dragMouseDown(e) 
            {
                e = e || window.event;
                e.preventDefault();
                // get the mouse cursor position at startup:
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                // call a function whenever the cursor moves:
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) 
            {
                e = e || window.event;
                e.preventDefault();
                // calculate the new cursor position:
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                // set the element's new position:
                elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
                elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
            }

            function closeDragElement() 
            {
                /* stop moving when mouse button is released:*/
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        //************************************************************//
        // Function: z-Index sort
        //************************************************************//
        function zIndexSort()
        {
            console.log("DEBUG: z-Index sort");
        }
        
        //************************************************************//
        // Function: Draw the entire screen
        //************************************************************//
        function drawScreen() 
        {
            // Get the layers to draw
            let viewLayer = [];

            for (i = 0; i < viewLayerInput.length; i++) 
            {
                if (viewLayerInput[i].checked)
                {
                    viewLayer.push(viewLayerInput[i].value);
                }
            }
            //
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            //
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            //
            ctx.save();
            //
            ctx.setTransform(viewportTransform.scale, 0, 0, viewportTransform.scale, viewportTransform.x, viewportTransform.y);
            //
            //
            // Place origin coordinates (0,0) at top-left corner

            // set defaults
            ctx.font         = '16px chalkboard';
            ctx.fillStyle    = 'black';
            ctx.textAlign    = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("(0,0)", extBorder - 10, extBorder - 10);

            // draw landscape border
            ctx.lineWidth   = 2;
            ctx.lineStyle   = "solid";
            ctx.strokeStyle = "green";
            const v0 = {x : extBorder +    0, y : extBorder +    0}
            const v1 = {x : extBorder + 3000, y : extBorder +   30}
            const v2 = {x : extBorder + 3000, y : extBorder + 2000}
            const v3 = {x : extBorder +    0, y : extBorder + 2000}
            const arcV2V3 = {x : extBorder + 1900, y : extBorder + 1900}
            
            ctx.beginPath();
            ctx.moveTo(v0.x, v0.y);
            ctx.lineTo(v1.x, v1.y);
            ctx.lineTo(v2.x, v2.y);
            ctx.quadraticCurveTo(arcV2V3.x, arcV2V3.y, v3.x, v3.y);
            ctx.closePath();
            // ctx.fill();
            ctx.stroke();

            // Draw shapes stored in shapes array
            for (let i = 0; i < shapes.length; i++) 
            {
                if (viewLayer.includes("all") || viewLayer.includes(shapes[i].layer))
                {
                    shapes[i].draw();
                }
            }
            // Draw the shape that is currently being created/modified
            if (activeShape)
            {
                activeShape.draw();
            }
            // Draw group bounding box
            if (activeGroupFlag)
            {
                activeGroup.drawBoundingBox();
            } 
            //
            ctx.restore();
        }

        //************************************************************//
        // Function: Save the canvas to the server db
        //************************************************************//
        save = document.getElementById("id_save");
        save.onclick = (event) => 
        {
            // AR: Is this necessary?
            event.preventDefault();
            // Acquire the CSRF token
            const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
            // Concatenate data to be saved into a single array
            saveData = [...shapes, ...shapeGroups];

            console.log("shapes:", shapes);

            // Converts the JavaScript object to a JSON string
            let saveData_JSON = JSON.stringify(saveData);
            // Send the data to be saved back to the Django view
            const postURL = window.location.pathname;
            // Sends the HTTP request
            fetch(postURL, 
            {
               // Specifies the request method
                method: "POST",
                headers: 
                {
                    // Tells the server that the request body is in JSON format
                    'Content-Type': 'application/json',
                    //  Provides CSRF protection, necessary for Django forms
                    'X-CSRFToken' : csrfToken
                },
                // JSON payload
                body: saveData_JSON
            })
            .then(response => response.json())
            .then(result => console.log('POST was a success: ${result}'))
            .catch(error => console.error('An error occurred: ${error}'))
        };
        
        //****************************************************************//
        // Function: Restore the canvas from the server db
        //****************************************************************//
        function restore()
        {
            const shapes_JSON = JSON.parse( "{{ shapes_JSON|escapejs }}" );
            let maxPlantID = 0;
            let maxShapeID = 0;
            let maxGroupID = 0;
            let maxZIndex  = 0;
            // restore saved objects (plants, shapes & groups)
            for (let i = 0; i < shapes_JSON.length; i++)
            {
                if (shapes_JSON[i].type == "plant")
                {
                    shapes.push(new Plant())
                    shapes.at(-1).restore(shapes_JSON[i]);
                    maxPlantID = Math.max(maxPlantID, shapes.at(-1).id);
                    maxZIndex  = Math.max(maxZIndex,  shapes.at(-1).zIndex);
                }
                else if (shapes_JSON[i].type == "line")
                {
                    shapes.push(new Line());
                    shapes.at(-1).restore(shapes_JSON[i]);
                    maxShapeID = Math.max(maxShapeID, shapes.at(-1).id);  
                    maxZIndex  = Math.max(maxZIndex,  shapes.at(-1).zIndex);
                }
                else if (shapes_JSON[i].type == "curve")
                {
                    shapes.push(new Curve());
                    shapes.at(-1).restore(shapes_JSON[i]);
                    maxShapeID = Math.max(maxShapeID, shapes.at(-1).id);
                    maxZIndex  = Math.max(maxZIndex,  shapes.at(-1).zIndex);
                }
                else if (shapes_JSON[i].type == "rectangle")
                {
                    shapes.push(new Rectangle());
                    shapes.at(-1).restore(shapes_JSON[i]);
                    maxShapeID = Math.max(maxShapeID, shapes.at(-1).id);
                    maxZIndex  = Math.max(maxZIndex,  shapes.at(-1).zIndex); 
                }
                else if (shapes_JSON[i].type == "circle")
                {
                    shapes.push(new Circle());
                    shapes.at(-1).restore(shapes_JSON[i]);
                    maxShapeID = Math.max(maxShapeID, shapes.at(-1).id);
                    maxZIndex  = Math.max(maxZIndex,  shapes.at(-1).zIndex); 
                }
                else if (shapes_JSON[i].type == "ellipse")
                {
                    shapes.push(new Ellipse());
                    shapes.at(-1).restore(shapes_JSON[i]);
                    maxShapeID = Math.max(maxShapeID, shapes.at(-1).id);
                    maxZIndex  = Math.max(maxZIndex,  shapes.at(-1).zIndex); 
                }
                else if (shapes_JSON[i].type == "polygon")
                {
                    shapes.push(new Polygon());
                    shapes.at(-1).restore(shapes_JSON[i]);
                    maxShapeID = Math.max(maxShapeID, shapes.at(-1).id);
                    maxZIndex  = Math.max(maxZIndex,  shapes.at(-1).zIndex); 
                }
                else if (shapes_JSON[i].type == "group")
                {
                    shapeGroups.push(new ShapeGroup(nextGroupID));
                    shapeGroups.at(-1).restore(shapes_JSON[i]);
                    maxGroupID = Math.max(maxGroupID, shapeGroups.at(-1).id);
                    maxZIndex  = Math.max(maxZIndex,  shapes.at(-1).zIndex);
                }
            }
            nextPlantID = maxPlantID + 1;
            nextShapeID = maxShapeID + 1;
            nextGroupID = maxGroupID + 1;
            nextZIndex  = maxZIndex  + 1;

            console.log("=======================================");
            console.log("Retrieving landscape design from server");
            console.log("=======================================");
            console.log("DEBUG: restored shapes:", shapes);
            console.log("DEBUG: restored shapeGroups:", shapeGroups);
            console.log("=======================================");
        }         

        //************************************************************//
        // Function: Clear the canvas of all shapes
        //************************************************************//
        clear = document.getElementById("id_clear");
        clear.onclick = (event) => 
        {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            shapes.length = 0;
            shapeGroups.length = 0;
        };  
    }

    // update zoom slider value on form in realtime
    document.getElementById('id_zoom_slider').addEventListener('input', synchZoomOutput);
    function synchZoomOutput(event)
    {
        document.getElementById('zoom').value = event.target.value;
    }
    //-----------------------------------------------------//
    // Code for drawing freeform lines on canvas via mouse //
    //-----------------------------------------------------//
    // function canvasApp()
    // {
    //     // Flag to track if the user is drawing
    //     let createShape = false; 
    //     // Store the last mouse position
    //     let lastX, lastY; 

    //     canvas.addEventListener('mousedown', startDrawing);
    //     canvas.addEventListener('mousemove', draw);
    //     canvas.addEventListener('mouseup', stopDrawing);
    //     // Stop drawing if mouse leaves the canvas
    //     canvas.addEventListener('mouseout', stopDrawing); 

    //     function startDrawing(event) {
    //         createShape = true;
    //         lastX = event.offsetX;
    //         lastY = event.offsetY;
    //         ctx.beginPath(); // Start a new path
    //         ctx.moveTo(lastX, lastY); // Move to the starting point
    //     }

    //     function draw(event) {
    //         if (!createShape) return; // Don't draw if not drawing
    //         ctx.lineTo(event.offsetX, event.offsetY); // Draw a line to the current position
    //         ctx.stroke(); // Stroke the line
    //         lastX = event.offsetX;
    //         lastY = event.offsetY;
    //     }

    //     function stopDrawing(event) {
    //         createShape = false;
    //     }
    // }

</script>
{% endblock js %}