<!-- app/plants/templates/gardens_plan.html -->
{% extends "plants/master.html" %}

{% block title %}
  <title>Garden | Plan</title>
{% endblock title %}

{% block css %}
  <style>
    canvas {
      border: 2px solid black;
    }
  </style>
{% endblock css %}

{% block header-completion %}
    <!-- complete the header from master.html -->
    <div class="w3-bar w3-green">
      <h1 class="w3-bar-item">My Garden Plan</h1>
    </div>
  </div>
{% endblock header-completion %}

{% block content %}
  <div class="w3-container" style="margin-top:140px;">
    <!-- Canvas tools-->
    <form>
      Action: 
      <select id="id_action">
        <option value="select">select</option>
        <option value="draw">draw</option>
        <option value="pan" >pan </option>
        <option value="zoom">zoom </option>
      </select>

      Shape: 
      <select id="id_shape">
        <option value="rectangle">rectangle</option>
        <option value="circle"   >circle   </option>
        <option value="polygon"  >polygon  </option>
      </select>

      Fill Color: 
      <input  type="color"  id="id_fill_color" value="#ff0000"/>

      <button type="button" id="id_save" class="w3-button w3-gray  w3-round">Save</button>
      <button type="button" id="id_clear" class="w3-button w3-gray  w3-round">Clear</button>
      <br>

    <!-- Canvas -->
    <canvas id="myCanvas">
      Your browser does not support HTML 5 Canvas
    </canvas>
  </div>
{% endblock content %}

{% block js %}
<script>

    // Wait until the window has been fully loaded
    window.onload = canvasApp;

    function canvasApp()
    {
        // setup the canvas
        const canvas = document.getElementById("myCanvas");
        const ctx = canvas.getContext("2d");
        canvas.height = 500; // px
        canvas.width  = 800; // px

        // setup variables
        let xStart,        yStart;      // starting coordinates for drawing
        let xSelect,       ySelect;     // mouse selection coordinates
        let xSelectSave,   ySelectSave; //
        let xTrans,        yTrans;      // translated mouse selection coordinates
        let xCenter,       yCenter;     // center of selected object
        let xCurrent,      yCurrent;    // 
        let xMouse,        yMouse;      // current mouse position
        let xDelta,        yDelta;      // change in mouse position
        let zIndex;                     // current maximum z-index
        let angleInRadians = 0;         // rotation angle in radians
        let theta = 0;                  // rotation angle in radians

        // Initilize action flags
        let createShape = false;
        let selectShape = false;
        let resizeShape = false; 
        let rotateShape = false;
        let moveShape   = false;
        
        // setup objects
        // Get the previously stored shapes and draw on the canvas
        const shapes_JSON = JSON.parse( "{{ shapes_JSON|escapejs }}" );
        let shapes = shapes_JSON;
        let activeShape   = null;
        let handles       = [];
        let activeHandle  = null;
        let currentHandle = null;

        // keep track of our panning and zooming.
           const viewportTransform = { x: 0, y: 0, scale: 1}

        drawAllShapes();

        // setup the garden planner action
        let action = "select";
        let target = "";
        formElement = document.getElementById("id_action");
	    formElement.addEventListener("change", actionChanged, false);        
        function actionChanged(e)
        {
            target = e.target;
            action = target.value;
            // clear any existing handles
            handles = [];
        }

        // Setup the shape to be drawn
        let shapeOption = "rectangle";
        formElement = document.getElementById("id_shape");
	    formElement.addEventListener("change",  shapeChanged, false);
        function shapeChanged(e)
        {
            target = e.target;
            shapeOption = target.value;
        }

        // Setup the shape fill color
        let fillColor = "#ff0000";
        formElement = document.getElementById("id_fill_color");
        formElement.addEventListener('change', fillColorChanged, false);
        function fillColorChanged(e)
        {
            target = e.target;
            fillColor = target.value;
        }

        // mouse click events
        canvas.addEventListener("click", (e) => 
        {
            if (action == "select")
            {
                // this will disable the mousedown, mousemove, & mouseup events
                createShape = false;
                // clear any existing handles
                handles = [];
                // Capture the canvas selection point
                xSelect = e.clientX - canvas.offsetLeft;
                ySelect = e.clientY - canvas.offsetTop;
                // save the canvas selection point for later use
                xSelectSave = xSelect;
                ySelectSave = ySelect;
                // Go through each shape to see if it has been selected
                for (let i = 0; i < shapes.length; i++) 
                {
                    // Obtain the original selection point
                    xSelect = xSelectSave;
                    ySelect = ySelectSave;

                    if (shapes[i].type == 'rectangle')
                    {
                        // translate mouse click coordinates if shape is rotated
                        //   ð›¼+(ð‘¥âˆ’ð›¼)cosðœƒâˆ’(ð‘¦âˆ’ð›½)sinðœƒ
                        //   ð›½+(ð‘¥âˆ’ð›¼)sinðœƒ+(ð‘¦âˆ’ð›½)cosðœƒ
                        if(shapes[i].rotation != 0)
                        {
                            xCenter = shapes[i].x + shapes[i].width  / 2;
                            yCenter = shapes[i].y + shapes[i].height / 2;
                            theta   = shapes[i].rotation * -1;

                            xTrans = Math.trunc(xCenter + (xSelect - xCenter) * Math.cos(theta) - (ySelect - yCenter) * Math.sin(theta))
                            yTrans = Math.trunc(yCenter + (xSelect - xCenter) * Math.sin(theta) + (ySelect - yCenter) * Math.cos(theta))
                            
                            xSelect = xTrans;
                            ySelect = yTrans;
                        }

                        // Determine in the selection point is contained within the rectangle
                        // It so, place resize handles on object
                        if (xSelect >= shapes[i].x &&
                            xSelect <= shapes[i].x + shapes[i].width && 
                            ySelect >= shapes[i].y &&
                            ySelect <= shapes[i].y + shapes[i].height)
                        {
                            // top left handle
                            currentHandle = placeHandle("top-left",
                                                        shapes[i].x,
                                                        shapes[i].y,
                                                        shapes[i].rotation,
                                                        i);
                            handles.push(currentHandle);
                            
                            // top middle handle
                            currentHandle = placeHandle("top-middle",
                                                        shapes[i].x + shapes[i].width/2,
                                                        shapes[i].y,
                                                        shapes[i].rotation,
                                                        i);
                            handles.push(currentHandle);

                            // top right handle
                            currentHandle = placeHandle("top-right",
                                                        shapes[i].x + shapes[i].width, 
                                                        shapes[i].y,
                                                        shapes[i].rotation,
                                                        i);
                            handles.push(currentHandle);

                            // right middle handle
                            currentHandle = placeHandle("right-middle",
                                                        shapes[i].x + shapes[i].width, 
                                                        shapes[i].y + shapes[i].height/2,
                                                        shapes[i].rotation,
                                                        i);
                            handles.push(currentHandle);

                            // bottom right handle
                            currentHandle = placeHandle("bottom-right",
                                                        shapes[i].x + shapes[i].width, 
                                                        shapes[i].y + shapes[i].height,
                                                        shapes[i].rotation,
                                                        i);
                            handles.push(currentHandle);

                            // bottom middle handle
                            currentHandle = placeHandle("bottom-middle",
                                                       shapes[i].x + shapes[i].width/2,
                                                       shapes[i].y + shapes[i].height,
                                                       shapes[i].rotation,
                                                       i);
                            handles.push(currentHandle);
                        
                            // bottom left handle
                            currentHandle = placeHandle("bottom-left",
                                                       shapes[i].x,                   
                                                       shapes[i].y + shapes[i].height,
                                                       shapes[i].rotation,
                                                       i);
                            handles.push(currentHandle);

                            // left middle handle
                            currentHandle = placeHandle("left-middle",
                                                        shapes[i].x,
                                                        shapes[i].y + shapes[i].height/2,
                                                        shapes[i].rotation,
                                                        i);
                            handles.push(currentHandle);

                            // Place rotate handle on object
                            currentHandle = placeHandle("rotate",
                                                        shapes[i].x + shapes[i].width / 2,
                                                        shapes[i].y - 30,
                                                        shapes[i].rotation,
                                                        i);
                            handles.push(currentHandle);

                            // Indicate that the modify shape mode is enabled for the selected shape
                            selectShape = true;
                            activeShape = shapes[i];
                        }
                    }

                    if (shapes[i].type == "circle")
                    {
                        // find the distance of the cursor position from the circle center and compare to the radius
                        distance = Math.sqrt(Math.pow((xSelect - shapes[i].x), 2) + Math.pow((ySelect - shapes[i].y), 2))
                        if (distance <= shapes[i].radius)
                        {
                            // Place resize handles on object
                            currentHandle = placeHandle("top",
                                                        shapes[i].x, 
                                                        shapes[i].y - shapes[i].radius,
                                                        0,
                                                        i);
                            handles.push(currentHandle);

                            currentHandle = placeHandle("right",
                                                        shapes[i].x + shapes[i].radius, 
                                                        shapes[i].y,
                                                        0,
                                                        i);
                            handles.push(currentHandle);

                            currentHandle = placeHandle("bottom",
                                                        shapes[i].x, 
                                                        shapes[i].y + shapes[i].radius,
                                                        0,
                                                        i);
                            handles.push(currentHandle);

                            currentHandle = placeHandle("left",
                                                        shapes[i].x - shapes[i].radius, 
                                                        shapes[i].y,
                                                        0,
                                                        i);
                            handles.push(currentHandle);


                            // Indicate that the modify shape mode is enabled for the selected shape
                            selectShape = true;
                            activeShape = shapes[i];
                        }
                    } 
                    drawAllShapes();
                }
            }
        });

        // mouse down events - dependent on selected action and shape
        canvas.addEventListener("mousedown", (e) => 
        {
            // Draw a new shape
            if (action == "draw")
            {
                //
                if (shapeOption == "rectangle")
                {
                    createShape = true;
                    xStart = e.clientX - canvas.offsetLeft;
                    yStart = e.clientY - canvas.offsetTop;
                    activeShape = 
                    { 
                        type       : "rectangle", 
                        x          : xStart, 
                        y          : yStart,
                        width      : 0,
                        height     : 0,
                        color      : "#ffffff",
                        rotation   : 0,
                    };
                }
                else if (shapeOption == "circle")
                {
                    createShape = true;
                    xStart = e.clientX - canvas.offsetLeft;
                    yStart = e.clientY - canvas.offsetTop;
                    activeShape = 
                    { 
                        type       : "circle", 
                        x          : xStart, 
                        y          : yStart, 
                        radius     : 0,
                        startAngle : 0, 
                        endAngle   : 2 * Math.PI,
                        direction  : "clockwise",
                        color      : "#ffffff"
                    };
                }
                else if (shapeOption == "polygon")
                {
                    console.log("DEBUG: Got to polygon - mouse down");
                    createShape = true;
                }
            }
            
            // Modify an existing shape
            else if (action == 'select' && selectShape)
            {
                // Determine how much the mouse has moved from the initial mousedown location
                //   e.clientX = horizontal coordinate at which a mouse event occurred, 
                //               relative to the viewport's left edge
                //   e.clientY = verticle coordinate at which a mouse event occurred, 
                //               relative to the viewport's top edge
                //
                //   canvas.offsetLeft = canvas's left offset
                //   canvas.offsetTop  = canvas's top offset
                //
                //   xSelect = the x-coordinate of the click relative to the canvas
                //   ySelect = the y-coordinate of the click relative to the canvas
                xSelect = e.clientX - canvas.offsetLeft;
                ySelect = e.clientY - canvas.offsetTop;
                // save the selection point for future use
                xSelectSave = xSelect;
                ySelectSave = ySelect;
                activeHandle = null;

                if (activeShape.type == "rectangle")
                {
                    // check to see if the selected shape (via mouseclick) has been rotated
                    if(activeShape.rotation != 0)
                    {
                        // rotate the selection coorinates wrt activeShape before checking if handle has been selected
                        xCenter = activeShape.x + activeShape.width  / 2;
                        yCenter = activeShape.y + activeShape.height / 2;
                        theta   = activeShape.rotation * -1;

                        xTrans = Math.trunc(xCenter + (xSelect - xCenter) * Math.cos(theta) - (ySelect - yCenter) * Math.sin(theta))
                        yTrans = Math.trunc(yCenter + (xSelect - xCenter) * Math.sin(theta) + (ySelect - yCenter) * Math.cos(theta))

                        xSelect = xTrans;
                        ySelect = yTrans;
                    }
                    
                    // check to see if a handle has been selected
                    // AR: change for to 'while'
                    for(let i = 0; i < handles.length; i++)
                    {
                        let distance = Math.sqrt(Math.pow((xSelect - handles[i].x), 2) + Math.pow((ySelect - handles[i].y), 2))
                        // Determine if one of the handles has been selected
                        if (distance <= handles[i].radius)
                        {
                            // AR: Change if to switch
                            // Determine which handle has been selected
                            if (handles[i].location == "top-left")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "top-middle")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "top-right")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "right-middle")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "bottom-right")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "bottom-middle")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "bottom-left")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "left-middle")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if(handles[i].location == "rotate")
                            {
                                activeHandle = handles[i];
                                rotateShape = true;
                            }
                            // set the election point to the center of the handle
                            xCurrent = activeHandle.x;
                            yCurrent = activeHandle.y;
                        }
                    }
 
                    // If no handle of the active shape was selected check to see if the
                    // body of the active shape was selected
                    if (!activeHandle)
                    {
                        if (xSelect >= activeShape.x &&
                            xSelect <= activeShape.x + activeShape.width && 
                            ySelect >= activeShape.y &&
                            ySelect <= activeShape.y + activeShape.height)
                        {
                            moveShape   = true;
                            xCurrent = xSelect;
                            yCurrent = ySelect;
                        }
                    }
                }
                else if (activeShape.type == "circle")
                {
                    // check to see if a handle has been selected
                    // AR: change for to 'while'
                    for(let i = 0; i < handles.length; i++)
                    {
                        let distance = Math.sqrt(Math.pow((xSelect - handles[i].x), 2) + Math.pow((ySelect - handles[i].y), 2))
                        // Determine if one of the handles has been selected
                        if (distance <= handles[i].radius)
                        {
                            // AR: Change if to switch
                            // Determine which handle has been selected
                            if (handles[i].location == "top")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "right")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "bottom")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "left")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }

                            // set the election point to the center of the handle
                            xCurrent = activeHandle.x;
                            yCurrent = activeHandle.y;
                        }
                    }
                    // If no handle of the active shape was selected check to see if the
                    // body of the active shape was selected
                    if (!activeHandle)
                    {
                        // find the distance of the cursor position from the circle center and compare to the radius
                        distance = Math.sqrt(Math.pow((xSelect - activeShape.x), 2) + 
                                             Math.pow((ySelect - activeShape.y), 2))
                        if (distance <= activeShape.radius)
                        {
                            moveShape   = true;
                            xCurrent = xSelect;
                            yCurrent = ySelect;
                        }
                    }
                }
            }
        });

        // mouse move events - dependent on selected action and shape
        canvas.addEventListener("mousemove", (e) => 
        {
            // Return if we are not in a mouse down/move/up mode
            if (!createShape && !resizeShape && !rotateShape && !moveShape)
            {
                return;
            } 

            // get current mouse location
            xMouse = e.clientX - canvas.offsetLeft;
            yMouse = e.clientY - canvas.offsetTop;

            // determine how much mouse has moved
            // initial xCurrent & xCurrent were set via mousedown event
            xDelta = xMouse - xCurrent;
            yDelta = yMouse - yCurrent;

            // Draw the active shape
            if (action == "draw")
            {
                if (shapeOption == "rectangle")
                {
                    activeShape.width  = xMouse - xStart;
                    activeShape.height = yMouse - yStart;
                }

                else if (shapeOption == "circle")
                {
                    activeShape.radius = Math.sqrt(Math.pow(xMouse - xStart, 2) + Math.pow(yMouse - yStart, 2));
                }

                else if (shapeOption == "polygon")
                {
                    console.log("DEBUG: Got to polygon - mouse move");
                }

                // Set the fill color
                activeShape.color = fillColor;

                // Draw all previously created/saved shapes
                drawAllShapes();
                // Draw shape current being drawn
                drawShape(activeShape);
            }
            
            // Resize the selected shape
            else if (action == 'select' && resizeShape && activeShape.type == "rectangle")
            {
                // check to see if the selected shape (via mouseclick) has been rotated
                if(activeShape.type == "rectangle" && activeShape.rotation != 0)
                {
                    xSelect = xMouse;
                    ySelect = yMouse;

                    // rotate the selection coordinates wrt activeShape before checking if handle has been selected
                    xCenter = activeShape.x + activeShape.width  / 2;
                    yCenter = activeShape.y + activeShape.height / 2;
                    theta   = activeShape.rotation * -1;

                    xTrans = Math.trunc(xCenter + (xSelect - xCenter) * Math.cos(theta) - (ySelect - yCenter) * Math.sin(theta))
                    yTrans = Math.trunc(yCenter + (xSelect - xCenter) * Math.sin(theta) + (ySelect - yCenter) * Math.cos(theta))

                    xMouse = xTrans;
                    yMouse = yTrans;
                }

                // determine how much mouse has moved
                xDelta = xMouse - xCurrent;
                yDelta = yMouse - yCurrent;

                // modify the rectangle based upon the selected handle + mouse movement
                if (activeHandle.location == "top-left")
                {
                    activeShape.x      += xDelta;
                    activeShape.width  -= xDelta;
                    activeShape.y      += yDelta;
                    activeShape.height -= yDelta;

                    handles[5].x   += xDelta / 2;
                    handles[6].x   += xDelta;
                    handles[7].x   += xDelta;
                    handles[7].y   += yDelta / 2;
                    activeHandle.x += xDelta;
                    activeHandle.y += yDelta;
                    handles[1].x   += xDelta / 2;
                    handles[1].y   += yDelta;
                    handles[2].y   += yDelta;
                    handles[3].y   += yDelta / 2;

                    handles[8].x   += xDelta / 2;
                    handles[8].y   += yDelta;
                }
                else if (activeHandle.location == "top-middle")
                {
                    activeShape.y      += yDelta;
                    activeShape.height -= yDelta;

                    handles[7].y   += yDelta / 2;
                    handles[0].y   += yDelta;
                    activeHandle.y += yDelta;
                    handles[2].y   += yDelta;
                    handles[3].y   += yDelta / 2;

                    handles[8].y   += yDelta;
                }
                else if (activeHandle.location == "top-right")
                {
                    activeShape.width  += xDelta;
                    activeShape.y      += yDelta;
                    activeShape.height -= yDelta;

                    handles[7].y   += yDelta / 2;
                    handles[0].y   += yDelta;
                    handles[1].x   += xDelta / 2;
                    handles[1].y   += yDelta;
                    activeHandle.x += xDelta;
                    activeHandle.y += yDelta;
                    handles[3].x   += xDelta;
                    handles[3].y   += yDelta / 2;
                    handles[4].x   += xDelta;
                    handles[5].x   += xDelta / 2;

                    handles[8].x   += xDelta / 2;
                    handles[8].y   += yDelta;
                }
                else if (activeHandle.location == "right-middle")
                {                 
                    activeShape.width += xDelta;

                    handles[1].x   += xDelta / 2;
                    handles[2].x   += xDelta;
                    activeHandle.x += xDelta;
                    handles[4].x   += xDelta;
                    handles[5].x   += xDelta / 2;

                    handles[8].x   += xDelta / 2;
                }
                else if (activeHandle.location == "bottom-right")
                {
                    activeShape.width  += xDelta;
                    activeShape.height += yDelta;

                    handles[1].x   += xDelta / 2;
                    handles[2].x   += xDelta;
                    handles[3].x   += xDelta;
                    handles[3].y   += yDelta / 2;
                    activeHandle.x += xDelta;
                    activeHandle.y += yDelta;
                    handles[5].x   += xDelta / 2;
                    handles[5].y   += yDelta;
                    handles[6].y   += yDelta;
                    handles[7].y   += yDelta / 2;

                    handles[8].x   += xDelta / 2;
                }
                else if (activeHandle.location == "bottom-middle")
                {
                    activeShape.height += yDelta;

                    handles[3].y   += yDelta / 2;
                    handles[4].y   += yDelta;
                    activeHandle.y += yDelta;
                    handles[6].y   += yDelta;
                    handles[7].y   += yDelta / 2;
                }
                else if (activeHandle.location == "bottom-left")
                {
                    activeShape.x      += xDelta;
                    activeShape.width  -= xDelta;
                    activeShape.height += yDelta;

                    handles[3].y   += yDelta / 2;
                    handles[4].y   += yDelta;
                    handles[5].x   += xDelta / 2;
                    handles[5].y   += yDelta;
                    activeHandle.x += xDelta;
                    activeHandle.y += yDelta;
                    handles[7].x   += xDelta;
                    handles[7].y   += yDelta / 2;
                    handles[0].x   += xDelta;
                    handles[1].x   += xDelta / 2;

                    handles[8].x   += xDelta / 2;
                }
                else if (activeHandle.location == "left-middle")
                {
                    activeShape.x      += xDelta;
                    activeShape.width  -= xDelta;

                    handles[5].x       += xDelta / 2;
                    handles[6].x       += xDelta;
                    activeHandle.x     += xDelta;
                    handles[0].x       += xDelta;
                    handles[1].x       += xDelta / 2;

                    handles[8].x       += xDelta / 2;
                }
                // Draw all created/saved shapes
                drawAllShapes();
            }
            else if (action == 'select' && resizeShape && activeShape.type == "circle")
            {
                if (activeHandle.location == "top")
                {
                    activeShape.radius -= yDelta;

                    handles[0].y   += yDelta;
                    handles[1].x   -= yDelta;
                    handles[2].y   -= yDelta;
                    handles[3].x   += yDelta;
                }
                else if (activeHandle.location == "right")
                {
                    activeShape.radius += xDelta;

                    handles[0].y   -= xDelta;
                    handles[1].x   += xDelta;
                    handles[2].y   += xDelta;
                    handles[3].x   -= xDelta;
                }
                else if (activeHandle.location == "bottom")
                {
                    activeShape.radius += yDelta;

                    handles[0].y   -= yDelta;
                    handles[1].x   += yDelta;
                    handles[2].y   += yDelta;
                    handles[3].x   -= yDelta;
                }
                else if (activeHandle.location == "left")
                {
                    activeShape.radius -= xDelta;

                    handles[0].y   += xDelta;
                    handles[1].x   -= xDelta;
                    handles[2].y   -= xDelta;
                    handles[3].x   += xDelta;
                }
                // Draw all created/saved shapes
                drawAllShapes();    
            }
            
            // Rotate the selected shape
            else if (action == 'select' && rotateShape && activeShape.type == "rectangle")
            {
                // Determine the amount to rotate the shape based on the mouse movement
                // AR: Find better approach to control the rotation
                angleInRadians += (xDelta + yDelta) * 0.01;
                // angleInRadians = Math.atan2(yMouse - yCenter, xMouse - xCenter);
                // angleInRadians = 45 * (Math.PI / 180);

                activeShape.rotation = angleInRadians;

                // Set the rotatation angle for all handles associated with the shape
                for(let i = 0; i < handles.length; i++)
                {
                    handles[i].rotation = angleInRadians;
                }

                drawAllShapes();
            }
            
            // Move the selected shape
            else if (action == 'select' && moveShape)
            {
                activeShape.x  += xDelta;
                activeShape.y  += yDelta;

                for(let i = 0; i < handles.length; i++)
                {
                    handles[i].x += xDelta;
                    handles[i].y += yDelta;
                }
                // Draw all created/saved shapes
                drawAllShapes();
            }
            
            // capture the current mouse location
            xCurrent = xMouse;
            yCurrent = yMouse;
        });

        // mouse up events - dependent on selected action and shape
        canvas.addEventListener("mouseup", (e) => 
        {
            if (action == "draw")
            {
                if (shapeOption == "rectangle" && activeShape.width > 0 && activeShape.height > 0)
                {
                    shapes.push(activeShape);
                }
                else if (shapeOption == "circle" && activeShape.radius > 0)
                {
                    shapes.push(activeShape);
                }
                else if (shapeOption == "polygon")
                {
                    console.log("DEBUG: Got to polygon - mouse up");
                }
            }
            // reset the current shape and flags
            // handles = [];
            createShape = false;
            resizeShape = false;
            rotateShape = false;
            moveShape   = false;
            selectShape = false;
        });

        // Draw shape
        function drawShape(shape) 
        {
            if (shape.type === "rectangle") 
            {
                // ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
                ctx.fillStyle = shape.color;
                if(shape.rotation == 0)
                {
                    ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
                }
                else
                {
                    // find center of shape
                    xCenter = shape.x + (shape.width  / 2);
                    yCenter = shape.y + (shape.height / 2);
                                    
                    // ctx.setTransform(1, 0, 0, 1, 0, 0);

                    //
                    ctx.save();
                    // Translate to rectangle center
                    ctx.translate(xCenter, yCenter);
                    // Rotate
                    ctx.rotate(shape.rotation);
                    // Translate back
                    ctx.translate(-xCenter, -yCenter);
                    // Draw the rectangle
                    ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
                    //
                    ctx.restore();
                }
            }
            else if (shape.type === "circle") 
            {
                ctx.beginPath();
                ctx.arc(shape.x, shape.y, shape.radius, shape.startAngle, shape.endAngle, shape.direction);
                ctx.fillStyle = shape.color;
                ctx.fill();
                ctx.stroke();
            }
            else if (shape.type === "handle") 
            {
                // find center of associated shape to determine the point of rotation for handle
                xCenter = shapes[shape.shape_id].x + shapes[shape.shape_id].width  / 2;
                yCenter = shapes[shape.shape_id].y + shapes[shape.shape_id].height / 2;
                //
                ctx.save();
                // Translate to rectangle center
                ctx.translate(xCenter, yCenter);
                // Rotate
                ctx.rotate(shape.rotation);
                // Translate back
                ctx.translate(-xCenter, -yCenter);
                // Draw the handle
                ctx.beginPath();
                ctx.arc(shape.x, shape.y, shape.radius, shape.startAngle, shape.endAngle, shape.direction);
                // AR: change to non-filled circle
                ctx.fillStyle = shape.color;
                // ctx.fill(); // fill the handle
                ctx.stroke();
                //
                ctx.restore();
            }
        }

        // Place handle
        function placeHandle(location, x, y, rotation, shape_id)
        {
            handle = 
            { 
                type       : "handle", 
                x          : x, 
                y          : y, 
                radius     : 5,
                startAngle : 0, 
                endAngle   : 2 * Math.PI,
                direction  : "clockwise",
                color      : "#000000",
                location   : location,
                rotation   : rotation,
                shape_id   : shape_id
            };
            return(handle);       
        }
        
        // Draw all shapes stored in shape arrays
        function drawAllShapes() 
        {
            // clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            //
            for (let i = 0; i < shapes.length; i++) 
            {
                drawShape(shapes[i]);
            }
            //
            for (let i = 0; i < handles.length; i++) 
            {
                drawShape(handles[i]);         
            }
        }

        // function to save the canvas to db
        save = document.getElementById("id_save");
        save.onclick = async (event) => 
        {
            // AR: Is this necessary?
            event.preventDefault();
            // Acquire the CSRF token
            const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
            //  Converts the JavaScript object to a JSON string
            let shapes_JSON = JSON.stringify(shapes);
            // Send the drawing objects back to the Django view
            const postURL = window.location.pathname;
            // Sends the HTTP request
            fetch(postURL, 
            {
               // Specifies the request method
                method: "POST",
                headers: 
                {
                    // Tells the server that the request body is in JSON format
                    'Content-Type': 'application/json',
                    //  Provides CSRF protection, necessary for Django forms
                    'X-CSRFToken' : csrfToken
                },
                // JSON payload
                body: shapes_JSON
            })
            .then(response => response.json())
            .then(result => console.log('POST was a success: ${result}'))
            .catch(error => console.error('An error occurred: ${error}'))
            //
            // let returnURL = "{% url 'plants:gardens_plan' %}";
            // window.location.href = returnURL;
        };

        // function to clear the canvas of all shapes
        clear = document.getElementById("id_clear");
        clear.onclick = async (event) => 
        {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            shapes.length = 0;
        };
    }

    //-----------------------------------------------------//
    // Code for drawing freeform lines on canvas via mouse //
    //-----------------------------------------------------//
    // function canvasApp()
    // {
    //     // Flag to track if the user is drawing
    //     let createShape = false; 
    //     // Store the last mouse position
    //     let lastX, lastY; 

    //     canvas.addEventListener('mousedown', startDrawing);
    //     canvas.addEventListener('mousemove', draw);
    //     canvas.addEventListener('mouseup', stopDrawing);
    //     // Stop drawing if mouse leaves the canvas
    //     canvas.addEventListener('mouseout', stopDrawing); 

    //     function startDrawing(event) {
    //         createShape = true;
    //         lastX = event.offsetX;
    //         lastY = event.offsetY;
    //         ctx.beginPath(); // Start a new path
    //         ctx.moveTo(lastX, lastY); // Move to the starting point
    //     }

    //     function draw(event) {
    //         if (!createShape) return; // Don't draw if not drawing
    //         ctx.lineTo(event.offsetX, event.offsetY); // Draw a line to the current position
    //         ctx.stroke(); // Stroke the line
    //         lastX = event.offsetX;
    //         lastY = event.offsetY;
    //     }

    //     function stopDrawing(event) {
    //         createShape = false;
    //     }
    // }

    //----------------------------------//
    // Code for panning and zooming     //
    //----------------------------------//
    // function canvasApp()
    // {
    //   const canvas = document.getElementById("canvas");
    //   const ctx = canvas.getContext("2d"); 

    //   // keep track of our panning and zooming.
    //   const viewportTransform = { 
    //     x: 0, 
    //     y: 0, 
    //     scale: 1
    //   }

    //   // function to draw rectangles
    //   const drawRect = (x, y, width, height, color) => {
    //     ctx.strokeStyle = 'black';
    //     ctx.strokeRect(x, y, width, height);
    //     ctx.fillStyle = color;
    //     ctx.fillRect(x, y, width, height);
    //   }

    //   // Draw the landscape design
    //   const render = () => {
    //     //
    //     ctx.setTransform(1, 0, 0, 1, 0, 0);
    //     ctx.clearRect(0, 0, canvas.width, canvas.height);
    //     ctx.setTransform(viewportTransform.scale, 0, 0, viewportTransform.scale, viewportTransform.x, viewportTransform.y);
    //     // Draw garden border
    //     drawRect(0, 0, 3000, 1600, 'white' );
    //     // Draw non-garden areas
    //     //          x     y    w    h
    //     drawRect(1100,  500, 800, 800, 'grey' ); // house
    //     drawRect( 600,  500, 500, 600, 'grey' ); // garage
    //     drawRect( 600, 1100, 400, 500, 'grey' ); // driveway
    //     drawRect(2200,  100, 600, 300, 'blue' ); // pickleball court
    //     drawRect(2000,  500, 500, 700, 'red'  ); // pool decking
    //     drawRect(2050,  550, 400, 600, 'blue' ); // pool
    //     // Greenhouse
    //     // Garden shed
    //     // Playhouse
    //     // Bungalow

    //     // Draw garden areas
    //     drawRect(  80,  900, 480, 650, 'green'); // se lawn
    //     // Draw trees
    //     // Draw raised planter bed 1
    //   }

    //   // We need to keep track of our previous mouse position for later
    //   let previousX = 0, previousY = 0;

    //   const updatePanning = (e) => {
    //     const localX = e.clientX;
    //     const localY = e.clientY;

    //     viewportTransform.x += localX - previousX;
    //     viewportTransform.y += localY - previousY;

    //     previousX = localX;
    //     previousY = localY;
    //   }

    //   const updateZooming = (e) => {
    //     const oldScale = viewportTransform.scale;
    //     const oldX = viewportTransform.x;
    //     const oldY = viewportTransform.y;

    //     const localX = e.clientX;
    //     const localY = e.clientY;

    //     const previousScale = viewportTransform.scale;

    //     const newScale = viewportTransform.scale += e.yDelta * -0.01;

    //     const newX = localX - (localX - oldX) * (newScale / previousScale);
    //     const newY = localY - (localY - oldY) * (newScale / previousScale);

    //     viewportTransform.x = newX;
    //     viewportTransform.y = newY;
    //     viewportTransform.scale = newScale;
    //   }

    //   const onMouseMove = (e) => {
    //     updatePanning(e)
    //     render()
    //     console.log(e)
    //   }

    //   const onMouseWheel = (e) => {
    //     updateZooming(e)
    //     render()
    //     console.log(e)
    //   }

    //   canvas.addEventListener("mousedown", (e) => {
    //     previousX = e.clientX;
    //     previousY = e.clientY;

    //     canvas.addEventListener("mousemove", onMouseMove);
    //   })

    //   canvas.addEventListener("mouseup", (e) => {
    //     canvas.removeEventListener("mousemove", onMouseMove);
    //   }) 

    //   canvas.addEventListener("wheel", onMouseWheel);

    //   // initial canvas rendering
    //   render();
    // }

</script>
{% endblock js %}