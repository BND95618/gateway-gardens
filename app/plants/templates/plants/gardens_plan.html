<!-- app/plants/templates/gardens_plan.html -->
{% extends "plants/master.html" %}

{% block title %}
  <title>Garden | Plan</title>
{% endblock title %}

{% block css %}
    <style>

        canvas 
        {
            border: 2px solid black;
        }
        input
        {
            line-height: 80%;
        }
        /* To make the modal background fully transparent */
        /* You may need to add !important depending on other styles affecting the modal */
        .w3-modal 
        {
            background: none !important; 
            /* Allows clicks to pass through */
            pointer-events: none; 
        }

        /* Ensure the modal content is still interactive */
        .w3-modal-content 
        {
            pointer-events: auto; 
        }

        .ctxMenu
        {
            position: fixed;
            display: none; /* Hidden by default */
            background-color: #fff;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 1000; /* Ensure it's above other elements */
        }

        .ctxMenuItem 
        {
            padding: 8px 12px;
            cursor: pointer;
        }

        .ctxMenuItem:hover 
        {
            background-color: #f0f0f0;
        }

    </style>
{% endblock css %}

{% block header-completion %}
        <!-- complete the header from master.html -->
        <div class="w3-bar w3-green">
            <h1 class="w3-bar-item">My Garden Layout</h1>
        </div>
    </div>
{% endblock header-completion %}

{% block content %}
    <div class="w3-container" style="margin-top:140px;">
        <!-- Canvas -->
        <canvas id="myCanvas">
            Your browser does not support HTML 5 Canvas
        </canvas>

        <!-- Canvas tools-->
        <form class = "w3-margin-bottom, w3-light-grey">
            Action: 
            <select id="id_action">
                <option value="select"   >select   </option>
                <option value="add plant">add plant</option>
                <option value="draw"     >draw     </option>
                <option value="pan"      >pan      </option>
                <option value="zoom"     >zoom     </option>
            </select>

            <button type="button" id="id_save"  class="w3-button w3-padding-small w3-gray w3-round">Save</button>
            <button type="button" id="id_clear" class="w3-button w3-padding-small w3-gray w3-round">Clear</button>
        </form>

        <!-- Canvas tool options -->
        <form class = "w3-margin-bottom, w3-light-grey w3-text-black">
            <div id="id_plant_div" style="display: none;">
                Plant:
                <select id="id_plant">
                    <option value="--"> -- </option>
                    <optgroup label="Annual" class = "w3-text-black">
                        {% for plant in plants %}
                            {% if plant.type_x == "Annual" %}
                                <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                            {% endif %}
                        {% endfor %}
                    </optgroup>
                    <optgroup label="Fern">
                        {% for plant in plants %}
                            {% if plant.type_x == "Fern" %}
                                <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                            {% endif %}
                        {% endfor %}
                    </optgroup>
                    <optgroup label="Grass">
                        {% for plant in plants %}
                            {% if plant.type_x == "Grass" %}
                                <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                            {% endif %}
                        {% endfor %}
                    </optgroup>
                    <optgroup label="Groundcover">
                        {% for plant in plants %}
                            {% if plant.type_x == "Groundcover" %}
                                <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                            {% endif %}
                        {% endfor %}
                    </optgroup>
                    <optgroup label="Perennial">
                        {% for plant in plants %}
                            {% if plant.type_x == "Perennial" %}
                                <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                            {% endif %}
                        {% endfor %}
                    </optgroup>
                    <optgroup label="Shrub">
                        {% for plant in plants %}
                            {% if plant.type_x == "Shrub" %}
                                <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                            {% endif %}
                        {% endfor %}
                    </optgroup>
                    <optgroup label="Succulent">
                        {% for plant in plants %}
                            {% if plant.type_x == "Succulent" %}
                                <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                            {% endif %}
                        {% endfor %}
                    </optgroup>
                    <optgroup label="Succulent">
                        {% for plant in plants %}
                            {% if plant.type_x == "Succulent" %}
                                <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                            {% endif %}
                        {% endfor %}
                    </optgroup>
                    <optgroup label="Tree">
                        {% for plant in plants %}
                            {% if plant.type_x == "Tree" %}
                                <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                            {% endif %}
                        {% endfor %}
                    </optgroup>
                    <optgroup label="Vegetable">
                        {% for plant in plants %}
                            {% if plant.type_x == "Vegetable" %}
                                <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                            {% endif %}
                        {% endfor %}
                    </optgroup>
                    <optgroup label="Vine">
                        {% for plant in plants %}
                            {% if plant.type_x == "Vine" %}
                                <option value="{{ plant.commonName }}"> {{ plant.commonName }} </option>
                            {% endif %}
                        {% endfor %}
                    </optgroup>
                </select>
            </div>
            
            <div id="id_shape_div" style="display: none;">
                Shape: 
                <select id="id_shape">
                    <option value="line"     >line     </option>
                    <option value="rectangle">rectangle</option>
                    <option value="circle"   >circle   </option>
                    <option value="polygon"  >polygon  </option>
                    <option value="free form">free form</option>
                </select>
            </div>
            
            <div id="id_line_width_div" style="display: none;">
                Line Width: 
                <select id="id_line_width">
                    <option value="1">1 px</option>
                    <option value="2">2 px</option>
                    <option value="3">3 px</option>
                    <option value="4">4 px</option>
                </select>
            </div>
        
            <div id="id_line_style_div" style="display: none;">
                Line Style: 
                <select id="id_line_style">
                    <option value="solid" >solid </option>
                    <option value="dashed">dashed</option>
                    <option value="dotted">dotted</option>
                </select>
            </div>
    
            <div id="id_line_color_div" style="display: none;">
                Line Color: 
                <input  type="color"  id="id_line_color" value="#000000"/>
            </div>
    
            <div id="id_fill_color_div" style="display: none;">
                Fill Color: 
                <input  type="color"  id="id_fill_color" value="#ffffff"/>
            </div>
        </form>

        <!-- Display shape attributes below canvas -->
        <p><span id="id_shape_attributes"></span></p>

        <!-- Plant Details Modal -->
        <div id="plant_details_modal" class="w3-modal">
            <p> Modal HTML to be Inserted Here! </p>
        </div>

        <!-- Planner Shape Edit Modal -->
        <div id="planner_edit_modal" class="w3-modal">
            <div class="w3-modal-content w3-card-4 w3-animate-zoom" style="max-width:300px;">

                <header class="w3-container w3-green"> 
                    <!-- Close the shape edit modal -->
                    <span onclick="document.getElementById('planner_edit_modal').style.display='none'" 
                        class="w3-button w3-display-topright">&times;
                    </span>
                    <h3>Edit Shape</h2>
                </header>
                    
                <div class="w3-container w3-border-top w3-padding-8 w3-light-grey">
                    <div>
                        <!-- populate current attribute values from server response -->
                        <form id = "id_edit_form" name = "editForm" action = "">

                            <div class="line rectangle circle polygon">
                                <label for="labelForm" style="display: inline-block; width: 80px;">label: </label>
                                <input type="text" id="labelForm" name="labelForm" style="width: 120px;">
                                <br>
                            </div>

                            <div class="line">
                                <label for="xStartFtForm" style="display: inline-block; width: 80px;">X (start): </label>
                                <input type="number" id="xStartFtForm" name="xStartFtForm" style="width: 50px;">
                                <span>ft</span>
                                <input type="number" id="xStartInForm" name="xStartInForm" style="width: 50px;">
                                <span>in</span>
                                <br>

                                <label for="yStartFtForm" style="display: inline-block; width: 80px;">Y (start): </label>
                                <input type="number" id="yStartFtForm" name="yStartFtForm" style="width: 50px;">
                                <span>ft</span>
                                <input type="number" id="yStartInForm" name="yStartInForm" style="width: 50px;">
                                <span>in</span>
                                <br>

                                <label for="xEndFtForm" style="display: inline-block; width: 80px;">X (end): </label>
                                <input type="number" id="xEndFtForm" name="xEndFtForm" style="width: 50px;">
                                <span>ft</span>
                                <input type="number" id="xEndInForm" name="xEndInForm" style="width: 50px;">
                                <span>in</span>
                                <br>

                                <label for="yEndFtForm" style="display: inline-block; width: 80px;">Y (end): </label>
                                <input type="number" id="yEndFtForm" name="yEndFtForm" style="width: 50px;">
                                <span>ft</span>
                                <input type="number" id="yEndInForm" name="yEndInForm" style="width: 50px;">
                                <span>in</span>
                                <br>
                            </div>

                            <div class="rectangle">
                                <label for="xFtForm" style="display: inline-block; width: 80px;">X: </label>
                                <input type="number" id="xFtForm" name="xFtForm" style="width: 50px;">
                                <span>ft</span>
                                <input type="number" id="xInForm" name="xInForm" style="width: 50px;">
                                <span>in</span>
                                <br>

                                <label for="yFtForm" style="display: inline-block; width: 80px;">Y: </label>
                                <input type="number" id="yFtForm" name="yFtForm" style="width: 50px;">
                                <span>ft</span>
                                <input type="number" id="yInForm" name="yInForm" style="width: 50px;">
                                <span>in</span>
                                <br>
                            </div>

                            <div class="circle">
                                <label for="xCenterFtForm" style="display: inline-block; width: 80px;">X (center): </label>
                                <input type="number" id="xCenterFtForm" name="xCenterFtForm" style="width: 50px;">
                                <span>ft</span>
                                <input type="number" id="xCenterInForm" name="xCenterInForm" style="width: 50px;">
                                <span>in</span>
                                <br>

                                <label for="yCenterFtForm" style="display: inline-block; width: 80px;">Y (center): </label>
                                <input type="number" id="yCenterFtForm" name="yCenterFtForm" style="width: 50px;">
                                <span>ft</span>
                                <input type="number" id="yCenterInForm" name="yCenterInForm" style="width: 50px;">
                                <span>in</span>
                                <br>
                            </div>

                            <div class="polygon" id="polygonHTML">
                                <p>Polygon vertices go here!</p>
                            </div>

                            <div class="rectangle">
                                <label for="widthFtForm" style="display: inline-block; width: 80px;">width: </label>
                                <input type="number" id="widthFtForm" name="widthFtForm" style="width: 50px;">
                                <span>ft</span>
                                <input type="number" id="widthInForm" name="widthInForm" style="width: 50px;">
                                <span>in</span>
                                <br>

                                <label for="heightFtForm" style="display: inline-block; width: 80px;">height: </label>
                                <input type="number" id="heightFtForm" name="heightFtForm" style="width: 50px;">
                                <span>ft</span>
                                <input type="number" id="heightInForm" name="heightInForm" style="width: 50px;">
                                <span>in</span>
                                <br>
                            </div>

                            <div class="circle">
                                <label for="radiusFtForm" style="display: inline-block; width: 80px;">radius: </label>
                                <input type="number" id="radiusFtForm" name="radiusFtForm" style="width: 50px;">
                                <span>ft</span>
                                <input type="number" id="radiusInForm" name="radiusInForm" style="width: 50px;">
                                <span>in</span>
                                <br>
                            </div>

                            <div class="rectangle">
                                <label for="rotationForm" style="display: inline-block; width: 80px;">rotation: </label>
                                <input type="number" id="rotationForm" name="rotationForm" style="width: 50px;">
                                <span>degrees</span>
                                <br>
                            </div>

                            <div class="line rectangle circle polygon">
                                <label for="lineWidthForm" style="display: inline-block; width: 80px;">Line width:</label>
                                <input type="number" id="lineWidthForm" name="lineWidthForm" style="width: 50px;">
                                <span>pixels</span>
                                <br>

                                <label for="lineStyleForm" style="display: inline-block; width: 80px;">Line style:</label>
                                <select id="lineStyleForm" style="width: 100px;">
                                    <option value="solid" >solid </option>
                                    <option value="dashed">dashed</option>
                                    <option value="dotted">dotted</option>
                                </select>
                                <br>

                                <label for="lineColorForm" style="display: inline-block; width: 80px;">Line color:</label>
                                <input type="color" id="lineColorForm" name="lineColorForm">
                                <br>
                            </div>

                            <div class="rectangle circle polygon">
                                <label for="fillColorForm" style="display: inline-block; width: 80px;">Fill color:</label>
                                <input type="color" id="fillColorForm" name="fillColorForm">
                                <br>
                            </div>

                            <!-- on submit, process attribute value changes in Javascript -->
                            <input type="submit" value="Apply" class="w3-button w3-round-large w3-green">
                            <input type="reset"  value="Reset"  class="w3-button w3-round-large w3-grey">
                            <button type="button"               class="w3-button w3-round-large w3-red"
                                    onclick="document.getElementById('planner_edit_modal').style.display='none'">
                                    Exit
                            </button>
                        </form>
                    </div>
                </div>
            </div>
        </div>

        <!-- Context menu - Plant -->
        <div id="ctxPlantMenu" class="ctxMenu">
            <div class = "ctxMenuItem">Plant: Show Details</div>
            <div class = "ctxMenuItem">Plant: Duplicate</div>
            <div class = "ctxMenuItem">Plant: Delete</div>
        </div>

        <!-- Context menu - Shape -->
        <div id="ctxShapeMenu" class="ctxMenu">
            <div class = "ctxMenuItem">Shape: Edit</div>
            <div class = "ctxMenuItem">Shape: Duplicate</div>
            <div class = "ctxMenuItem">Shape: Delete</div>
        </div>
        
    </div> 
{% endblock content %}

{% block js %}
<script>

    // Wait until the window has been fully loaded
    window.onload = canvasApp;

    function canvasApp()
    {
        // setup the canvas
        const canvas  = document.getElementById("myCanvas");
        const ctx     = canvas.getContext("2d");
        const ctxShapeMenu = document.getElementById('ctxShapeMenu');
        canvas.width  = window.innerWidth  -  40;
        canvas.height = window.innerHeight - 300;
        
        // setup global variables
        let xSelect,        ySelect;        // mouse selection coordinates - relative
        let xSelectAbs,     ySelectAbs;     // mouse selection coordinates - absolute
        let xSelectAbsSave, ySelectAbsSave; //
        let xTransAbs,      yTransAbs;      // translated mouse selection coordinates
        let xShapeCenter,   yShapeCenter;   // center of selected object
        let xMouse,         yMouse;         // current mouse position - relative to viewport
        let xMouseAbs,      yMouseAbs;      // current mouse position - absolute
        let xDelta,         yDelta;         // change in mouse position
        let xDeltaAcc = 0,  yDeltaAcc = 0;  //
        let xPlot,          yPlot;          // Plot size
        let zIndex;                         // current maximum z-index
        let theta = 0;                      // rotation angle in radians
        let lineWidthDefault   = 1;         //
        let strokeStyleDefault = "black";   //
        let xPolygonVertex, yPolygonVertex; //
        let target = "";                    // selected menu item choice

        // set menu defaults
        let action      = "select";
        let shapeOption = "line";
        let lineWidth   = 1;
        let lineStyle   = "solid";
        let lineColor   = "black";
        let fillColor   = "white";

        let shapeIndex;

        // Initilize global action flags
        let createShape    = false;
        let selectShape    = false;
        let resizeShape    = false; 
        let rotateShape    = false;
        let moveShape      = false;
        let panning        = false;
        let selectShapeCtx = false;
        let polygonWIP     = false; // actively drawing the polygoon
        
        // setup global objects
        const shapes_JSON = JSON.parse( "{{ shapes_JSON|escapejs }}" );
        let shapes        = shapes_JSON;
        let activeShape   = null;
        let activeHandle  = null;
        let currentHandle = null;

        // setup global object arrays
        let polygonVertices = [];
        let handles         = [];
        let backgrounds     = [];

        // plant variables
        let requestedPlant;
        let activePlant = null;
        let selectPlantCtx = false;
        
        // keep track of our panning and zooming
        let viewportTransform = { x : 0, y : 0, scale : 1 }

        // Draw landscape border
        let extBorder = 120; // 10 ft exterior plot border in pixels
        xPlot = 3600;        // 300 ft at 12 px per foot
        yPlot = 2400;        // 200 ft at 12 px per foot
        // activeShape = 
        //             { 
        //                 type        : "rectangle-nofill", 
        //                 x           : extBorder,
        //                 y           : extBorder,
        //                 width       : xPlot,
        //                 height      : yPlot,
        //                 lineWidth   : 2,
        //                 lineStyle   : "solid",
        //                 strokeStyle : "green",
        //                 rotation    : 0
        //             };
        // backgrounds.push(activeShape);

        drawScreen();

        // setup the garden planner action
        formElement = document.getElementById("id_action");
	    formElement.addEventListener("change", (e) =>
        {
            target = e.target;
            action = target.value;
            //
            if ( action == 'select')
            {
                id_plant_div.style.display = 'none';
                id_shape_div.style.display = 'none';
                id_line_width_div.style.display = 'none';
                id_line_style_div.style.display = 'none';
                id_line_color_div.style.display = 'none';
                id_fill_color_div.style.display = 'none';
                id_shape_attributes.style.display = 'inline';
            }
            else if( action == 'add plant')
            {
                id_plant_div.style.display = 'inline';
                id_shape_div.style.display = 'inline';
                id_line_width_div.style.display = 'inline';
                id_line_style_div.style.display = 'inline';
                id_line_color_div.style.display = 'inline';
                id_fill_color_div.style.display = 'inline';
            }
            else if( action == 'draw')
            {
                id_plant_div.style.display = 'none';
                id_shape_div.style.display = 'inline';
                id_line_width_div.style.display = 'inline';
                id_line_style_div.style.display = 'inline';
                id_line_color_div.style.display = 'inline';
                id_shape_attributes.style.display = 'none';
            }
            else if( action == 'pan')
            {
                id_plant_div.style.display = 'none';
                id_shape_div.style.display = 'none';
                id_line_width_div.style.display = 'none';
                id_line_style_div.style.display = 'none';
                id_line_color_div.style.display = 'none';
                id_fill_color_div.style.display = 'none';
                id_shape_attributes.style.display = 'none';
            }
            else if( action == 'zoom')
            {
                id_plant_div.style.display = 'none';
                id_shape_div.style.display = 'none';
                id_line_width_div.style.display = 'none';
                id_line_style_div.style.display = 'none';
                id_line_color_div.style.display = 'none';
                id_fill_color_div.style.display = 'none';
                id_shape_attributes.style.display = 'none';
            }
            // clear any existing handles
            handles = [];
        });

        //************************************************************//
        // Get the details regarding the plant to be added
        //************************************************************//
        formElement = document.getElementById("id_plant");
        formElement.addEventListener("change", (e) =>
        {
            target = e.target;
            requestedPlant = target.value;
            console.log("DEBUG: Requested Plant:", requestedPlant);

            // Setup fetch parameters
            let url             = "{% url 'plants:plant_details_modal' %}";
            const requestMethod = "POST";
            const csrfToken     = document.querySelector('[name=csrfmiddlewaretoken]').value;
            const postData      = { requestedPlant : requestedPlant }
            const plant_details_modal = document.getElementById('plant_details_modal');

            // Fetch the plant details modal
            fetch(url, 
            {
                method: requestMethod,
                headers:
                {
                    // Tells the server that the request body is in JSON format
                    'Content-Type': 'application/json',
                    //  Provides CSRF protection, necessary for Django
                    'X-CSRFToken' : csrfToken
                },
                // Convert the dictionary to a JSON string
                body: JSON.stringify(postData),
            })
            .then(response => response.text())
            .then(html => { plant_details_modal.innerHTML = html; })
            // enable the model display
            plant_details_modal.style.display = 'block';

            // Fetch the plant details and create javascript object for later use
            url = "{% url 'plants:plant_fetch' %}"
            fetch(url,
            {
                method: requestMethod,
                headers: 
                {
                    // Tells the server that the request body is in JSON format
                    'Content-Type': 'application/json',
                    //  Provides CSRF protection, necessary for Django
                    'X-CSRFToken' : csrfToken
                },
                // Convert the dictionary to a JSON string
                body: JSON.stringify(postData),
            })
            .then(response => response.text())
            .then(activePlantJSON => 
            {
                // AR: Convert the array of one object to just an object - remove '[]'
                const activePlantObject = JSON.parse(activePlantJSON);
                activePlant = activePlantObject[0];

                // Calculate the radius
                let radiusInPx = (activePlant.width_feet * 12 + activePlant.width_inch) / 2;

                // Add parameters to draw the activePlant as a circle
                activePlant.isPlant    = true;
                activePlant.type       = "circle";
                activePlant.x          = 200;
                activePlant.y          = 200;
                activePlant.radius     = radiusInPx;
                activePlant.startAngle = 0;
                activePlant.endAngle   = 2 * Math.PI;
                activePlant.direction  = "clockwise";
                activePlant.lineWidth  = lineWidth;
                activePlant.lineStyle  = lineStyle;
                activePlant.lineColor  = lineColor;
                activePlant.fillColor  = fillColor;

                // Get the user defined label for the plant
                activePlant.label = prompt("Plant label:");

                // Push the plant into the drawshapes array
                shapes.push(activePlant);

                // Refrest the screen to show the newly added plant
                drawScreen();
            })
        });

        // Setup the shape to be drawn
        formElement = document.getElementById("id_shape");
	    formElement.addEventListener("change", (e) =>
        {
            target = e.target;
            shapeOption = target.value;
            if (shapeOption == "rectangle" || shapeOption == "circle" ||shapeOption == "polygon")
            {
                id_fill_color_div.style.display = 'inline';
            }
        });

        // Setup the shape line width
        formElement = document.getElementById("id_line_width");
        formElement.addEventListener('change', (e) =>
        {
            target = e.target;
            lineWidth = target.value;
        });

        // Setup the shape line style
        formElement = document.getElementById("id_line_style");
        formElement.addEventListener('change', (e) =>
        {
            target = e.target;
            lineStyle = target.value;
        });

        // Setup the shape line color
        formElement = document.getElementById("id_line_color");
        formElement.addEventListener('change', (e) =>
        {
            target = e.target;
            lineColor = target.value;
        });

        // Setup the shape fill color
        formElement = document.getElementById("id_fill_color");
        formElement.addEventListener('change', (e) =>
        {
            target = e.target;
            fillColor = target.value;
        });
        
        // Get the HTML element which will display the mouse XY coordinates
        let shapeAttributes = document.getElementById("id_shape_attributes");

        // When the window is resized, adjust canvas size to fit
        window.addEventListener("resize", function()
        {
            console.log("Got to canvas resize");
            console.log("window.innerWidth =", window.innerWidth);
            canvas.width  = window.innerWidth  -  40;
            canvas.height = window.innerHeight - 300;
            drawScreen();
        });

        // get edit form fields
        const labelForm     = document.getElementById('labelForm');
        // line coordinates
        const xStartFtForm  = document.getElementById('xStartFtForm');
        const xStartInForm  = document.getElementById('xStartInForm');
        const yStartFtForm  = document.getElementById('yStartFtForm');
        const yStartInForm  = document.getElementById('yStartInForm');
        const xEndFtForm    = document.getElementById('xEndFtForm');
        const xEndInForm    = document.getElementById('xEndInForm');
        const yEndFtForm    = document.getElementById('yEndFtForm');
        const yEndInForm    = document.getElementById('yEndInForm');
        // rectangle coordinates
        const xFtForm       = document.getElementById('xFtForm');
        const xInForm       = document.getElementById('xInForm');
        const yFtForm       = document.getElementById('yFtForm');
        const yInForm       = document.getElementById('yInForm');
        // circle coordinates
        const xCenterFtForm = document.getElementById('xCenterFtForm');
        const xCenterInForm = document.getElementById('xCenterInForm');
        const yCenterFtForm = document.getElementById('yCenterFtForm');
        const yCenterInForm = document.getElementById('yCenterInForm');
        // polygon coordinates
        const polygonHTML   = document.getElementById('polygonHTML');
        //
        const widthFtForm   = document.getElementById('widthFtForm');
        const widthInForm   = document.getElementById('widthInForm');
        const heightFtForm  = document.getElementById('heightFtForm');
        const heightInForm  = document.getElementById('heightInForm');
        //
        const radiusFtForm  = document.getElementById('radiusFtForm');
        const radiusInForm  = document.getElementById('radiusInForm');
        //
        const rotationForm  = document.getElementById('rotationForm');
        //
        const lineWidthForm = document.getElementById('lineWidthForm');
        //
        const lineStyleForm = document.getElementById('lineStyleForm');
        const lineColorForm = document.getElementById('lineColorForm');
        const fillColorForm = document.getElementById('fillColorForm');

        const line      = document.getElementsByClassName('line');
        const rectangle = document.getElementsByClassName('rectangle');
        const circle    = document.getElementsByClassName('circle');
        const polygon   = document.getElementsByClassName('polygon');

        //************************************************************//
        // mouse click events
        //************************************************************//
        canvas.addEventListener("click", (e) => 
        {
            console.log("DEBUG: *** Mouse click event registered ***");

            if (action == "select")
            {
                // reset the active shape flag
                selectShape = false;
                activeShape = null;
                // this will disable the mousedown, mousemove, & mouseup events
                createShape = false;
                // clear any existing handles
                handles = [];

                // canvas selection point - absolute position
                xSelectAbs = (e.clientX - canvas.offsetLeft - viewportTransform.x) / viewportTransform.scale ;
                ySelectAbs = (e.clientY - canvas.offsetTop  - viewportTransform.y) / viewportTransform.scale ;

                // save the canvas selection point for later use
                xSelectSaveAbs = xSelectAbs;
                ySelectSaveAbs = ySelectAbs;

                // Go through each shape to see if it has been selected
                for (let i = 0; i < shapes.length; i++) 
                {
                    // Obtain the original selection point
                    xSelectAbs = xSelectSaveAbs;
                    ySelectAbs = ySelectSaveAbs;

                    if (shapes[i].type == 'line')
                    {
                        // Determine in the selection point is close to the line
                        // If so, place resize handles on object
                        if(selectLine(shapes[i], xSelectAbs, ySelectAbs))
                        {
                            // clear any existing handles
                            handles = [];

                            // place start point handle
                            currentHandle = placeHandle("start",
                                                        shapes[i].xStart,
                                                        shapes[i].yStart,
                                                        0,
                                                        i);
                            handles.push(currentHandle);

                            // place end point handle
                            currentHandle = placeHandle("end",
                                                        shapes[i].xEnd,
                                                        shapes[i].yEnd,
                                                        0,
                                                        i);
                            handles.push(currentHandle);
                            // Indicate that the modify shape mode is enabled for the selected shape
                            selectShape = true;
                            activeShape = shapes[i];
                        }
                    }
                    else if (shapes[i].type == 'rectangle')
                    {
                        // translate mouse click coordinates if shape is rotated
                        //   ð›¼+(ð‘¥âˆ’ð›¼)cosðœƒâˆ’(ð‘¦âˆ’ð›½)sinðœƒ
                        //   ð›½+(ð‘¥âˆ’ð›¼)sinðœƒ+(ð‘¦âˆ’ð›½)cosðœƒ
                        if(shapes[i].rotation != 0)
                        {
                            xShapeCenter = shapes[i].x + shapes[i].width  / 2;
                            yShapeCenter = shapes[i].y + shapes[i].height / 2;
                            theta   = shapes[i].rotation * -1;

                            xTransAbs = Math.trunc(xShapeCenter + 
                                                  (xSelectAbs - xShapeCenter) * Math.cos(theta) - 
                                                  (ySelectAbs - yShapeCenter) * Math.sin(theta))
                            yTransAbs = Math.trunc(yShapeCenter + 
                                                  (xSelectAbs - xShapeCenter) * Math.sin(theta) + 
                                                  (ySelectAbs - yShapeCenter) * Math.cos(theta))
                            
                            xSelectAbs = xTransAbs;
                            ySelectAbs = yTransAbs;
                        }

                        // Determine if the selection point is contained within the rectangle
                        // If so, place resize handles on object
                        if(selectRectangle(shapes[i], xSelectAbs, ySelectAbs))
                        {
                            // clear any existing handles
                            handles = [];

                            // place top left handle
                            currentHandle = placeHandle("top-left",
                                                        shapes[i].x,
                                                        shapes[i].y,
                                                        shapes[i].rotation,
                                                        i);
                            handles.push(currentHandle);
                            
                            // place top middle handle
                            currentHandle = placeHandle("top-middle",
                                                        shapes[i].x + shapes[i].width/2,
                                                        shapes[i].y,
                                                        shapes[i].rotation,
                                                        i);
                            handles.push(currentHandle);

                            // place top right handle
                            currentHandle = placeHandle("top-right",
                                                        shapes[i].x + shapes[i].width, 
                                                        shapes[i].y,
                                                        shapes[i].rotation,
                                                        i);
                            handles.push(currentHandle);

                            // place right middle handle
                            currentHandle = placeHandle("right-middle",
                                                        shapes[i].x + shapes[i].width, 
                                                        shapes[i].y + shapes[i].height/2,
                                                        shapes[i].rotation,
                                                        i);
                            handles.push(currentHandle);

                            // place bottom right handle
                            currentHandle = placeHandle("bottom-right",
                                                        shapes[i].x + shapes[i].width, 
                                                        shapes[i].y + shapes[i].height,
                                                        shapes[i].rotation,
                                                        i);
                            handles.push(currentHandle);

                            // place bottom middle handle
                            currentHandle = placeHandle("bottom-middle",
                                                       shapes[i].x + shapes[i].width/2,
                                                       shapes[i].y + shapes[i].height,
                                                       shapes[i].rotation,
                                                       i);
                            handles.push(currentHandle);
                        
                            // place bottom left handle
                            currentHandle = placeHandle("bottom-left",
                                                       shapes[i].x,                   
                                                       shapes[i].y + shapes[i].height,
                                                       shapes[i].rotation,
                                                       i);
                            handles.push(currentHandle);

                            // place left middle handle
                            currentHandle = placeHandle("left-middle",
                                                        shapes[i].x,
                                                        shapes[i].y + shapes[i].height/2,
                                                        shapes[i].rotation,
                                                        i);
                            handles.push(currentHandle);

                            // place Place rotate handle on object
                            currentHandle = placeHandle("rotate",
                                                        shapes[i].x + shapes[i].width / 2,
                                                        shapes[i].y - 30,
                                                        shapes[i].rotation,
                                                        i);
                            handles.push(currentHandle);

                            // Indicate that the modify shape mode is enabled for the selected shape
                            selectShape = true;
                            activeShape = shapes[i];
                        }
                    }
                    else if (shapes[i].type == "circle")
                    {
                        // Determine if the selection point is within the circle
                        // If so, place resize handles on object
                        if(selectCircle(shapes[i], xSelectAbs, ySelectAbs))
                        {
                            // clear any existing handles
                            handles = [];

                            // Place resize handles on object
                            currentHandle = placeHandle("top",
                                                        shapes[i].x, 
                                                        shapes[i].y - shapes[i].radius,
                                                        0,
                                                        i);
                            handles.push(currentHandle);

                            currentHandle = placeHandle("right",
                                                        shapes[i].x + shapes[i].radius, 
                                                        shapes[i].y,
                                                        0,
                                                        i);
                            handles.push(currentHandle);

                            currentHandle = placeHandle("bottom",
                                                        shapes[i].x, 
                                                        shapes[i].y + shapes[i].radius,
                                                        0,
                                                        i);
                            handles.push(currentHandle);

                            currentHandle = placeHandle("left",
                                                        shapes[i].x - shapes[i].radius, 
                                                        shapes[i].y,
                                                        0,
                                                        i);
                            handles.push(currentHandle);

                            // Indicate that the modify shape mode is enabled for the selected shape
                            selectShape = true;
                            activeShape = shapes[i];
                        }
                    } 
                    else if (shapes[i].type == "polygon")
                    {
                        // Check to see if the selection point is within the polygon
                        if(selectPolygon(shapes[i], xSelectAbs, ySelectAbs))
                        {
                            // clear any existing handles
                            handles = [];

                            // Place resize handles on object
                            for (let j = 0; j < shapes[i].vertices.length; j++)
                            {
                                currentHandle = placeHandle("v" + j,
                                                        shapes[i].vertices[j].x, 
                                                        shapes[i].vertices[j].y,
                                                        0,
                                                        i);
                                handles.push(currentHandle);
                            }
                            selectShape = true;
                            activeShape = shapes[i];
                        }
                    }
                }

                // Display the attributes for the selected shape
                if (selectShape)
                {
                    shapeAttributes.innerHTML = displayAttributes(activeShape);
                }
                else
                {
                    shapeAttributes.innerHTML = "<p>No shape selected</p>";
                }

                // Draw the entire screen
                drawScreen();
            }
        });

        //************************************************************//
        // mouse down events - dependent on selected action and shape
        //************************************************************//
        canvas.addEventListener("mousedown", (e) => 
        {
            // Return if we are not in a mouse down/move/up mode
            if (!selectShape && action != "draw" && action != "pan")
            {
                return;
            } 

            console.log("DEBUG: *** Mouse down event registered ***");

            // Canvas selection point - absolute position
            xSelectAbs = Math.round((e.clientX - canvas.offsetLeft - viewportTransform.x) / viewportTransform.scale);
            ySelectAbs = Math.round((e.clientY - canvas.offsetTop  - viewportTransform.y) / viewportTransform.scale);

            // Draw a new shape
            if (action == "draw")
            {
                if (shapeOption == "line")
                {
                    // console.log("DEBUG: Start drawing a line");
                    createShape = true;
                    activeShape = 
                    { 
                        label     : "line",
                        type      : "line", 
                        xStart    : xSelectAbs, 
                        yStart    : ySelectAbs,
                        xEnd      : xSelectAbs, 
                        yEnd      : ySelectAbs,
                        lineWidth : lineWidth,
                        lineStyle : lineStyle,
                        lineColor : lineColor
                    };
                }
                else if (shapeOption == "rectangle")
                {
                    createShape = true;
                    activeShape = 
                    { 
                        label     : "rectangle",
                        type      : "rectangle", 
                        x         : xSelectAbs, 
                        y         : ySelectAbs,
                        width     : 0,
                        height    : 0,
                        lineWidth : lineWidth,
                        lineStyle : lineStyle,
                        lineColor : lineColor,
                        fillColor : fillColor,
                        rotation  : 0
                    };
                }
                else if (shapeOption == "circle")
                {
                    createShape = true;
                    activeShape = 
                    { 
                        label      : "circle",
                        type       : "circle", 
                        x          : xSelectAbs, 
                        y          : ySelectAbs, 
                        radius     : 0,
                        startAngle : 0, 
                        endAngle   : 2 * Math.PI,
                        direction  : "clockwise",
                        lineWidth  : lineWidth,
                        lineStyle  : lineStyle,
                        lineColor  : lineColor,
                        fillColor  : fillColor
                    };
                }
                else if (shapeOption == "polygon")
                {
                    if (polygonWIP == false)
                    {
                        // Create polygon object
                        createShape = true;
                        polygonVertices = [];
                        activeShape = 
                        { 
                            label     : "polygon",
                            type      : "polygon", 
                            vertices  : polygonVertices, 
                            lineWidth : lineWidth,
                            lineStyle : lineStyle,
                            lineColor : lineColor,
                            fillColor : fillColor,
                            rotation  : 0,
                            status    : "WIP"
                        };

                        // Set polygon starting point
                        activeShape.vertices.push({ x : xSelectAbs, y : ySelectAbs });

                        // Polygon drawing in process
                        polygonWIP  = true;
                    }
                    
                    createShape = true;
                    // set the starting coordinates for the next point
                    xPolygonVertex = xSelectAbs;
                    yPolygonVertex = ySelectAbs;
                    activeShape.vertices.push({ x : xPolygonVertex, y : yPolygonVertex });
                }

                xSelectSaveAbs = xSelectAbs;
                ySelectSaveAbs = ySelectAbs;
                // display shape attributes text
                id_shape_attributes.style.display = 'inline';
            }
            
            // Modify an existing shape
            else if (action == 'select' && selectShape)
            {
                // Determine how much the mouse has moved from the initial mousedown location
                //   e.clientX = horizontal coordinate at which a mouse event occurred, 
                //               relative to the viewport's left edge
                //   e.clientY = verticle coordinate at which a mouse event occurred, 
                //               relative to the viewport's top edge
                //
                //   canvas.offsetLeft = canvas's left offset
                //   canvas.offsetTop  = canvas's top offset
                //
                // save the selection point for future use
                xSelectSaveAbs = xSelectAbs;
                ySelectSaveAbs = ySelectAbs;
                activeHandle = null;

                if (activeShape.type == "line")
                {
                    // check to see if a handle has been selected
                    // AR: change for to 'while'
                    for(let i = 0; i < handles.length; i++)
                    {
                        let distance = Math.sqrt(Math.pow((xSelectAbs - handles[i].x), 2) + 
                                                 Math.pow((ySelectAbs - handles[i].y), 2))
                        // Determine if one of the handles has been selected
                        if (distance <= handles[i].radius)
                        {
                            // AR: Change if to switch
                            // Determine which handle has been selected
                            if (handles[i].location == "start")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "end")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            // set the election point to the center of the handle
                            xSelectSaveAbs = activeHandle.x;
                            ySelectSaveAbs = activeHandle.y;
                        }
                    }
                    // If no handle of the active shape was selected check to see if the
                    // body of the active shape was selected
                    if (!activeHandle)
                    {
                        if(selectLine(activeShape, xSelectAbs, ySelectAbs))
                        {
                            moveShape = true;
                        }
                    }
                }
                else if (activeShape.type == "rectangle")
                {
                    // check to see if the selected shape (via mouseclick) has been rotated
                    if(activeShape.rotation != 0)
                    {
                        // rotate the selection coorinates wrt activeShape before checking if handle has been selected
                        xShapeCenter = activeShape.x + activeShape.width  / 2;
                        yShapeCenter = activeShape.y + activeShape.height / 2;
                        theta   = activeShape.rotation * -1;

                        xTransAbs = Math.trunc(xShapeCenter + 
                                              (xSelectAbs - xShapeCenter) * Math.cos(theta) - 
                                              (ySelectAbs - yShapeCenter) * Math.sin(theta))
                        yTransAbs = Math.trunc(yShapeCenter + 
                                              (xSelectAbs - xShapeCenter) * Math.sin(theta) + 
                                              (ySelectAbs - yShapeCenter) * Math.cos(theta))

                        xSelectAbs = xTransAbs;
                        ySelectAbs = yTransAbs;
                    }
                    
                    // check to see if a handle has been selected
                    // AR: change for to 'while'
                    for(let i = 0; i < handles.length; i++)
                    {
                        let distance = Math.sqrt(Math.pow((xSelectAbs - handles[i].x), 2) + 
                                                 Math.pow((ySelectAbs - handles[i].y), 2))
                        // Determine if one of the handles has been selected
                        if (distance <= handles[i].radius)
                        {
                            // AR: Change if to switch
                            // Determine which handle has been selected
                            if (handles[i].location == "top-left")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "top-middle")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "top-right")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "right-middle")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "bottom-right")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "bottom-middle")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "bottom-left")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "left-middle")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if(handles[i].location == "rotate")
                            {
                                activeHandle = handles[i];
                                rotateShape = true;
                            }
                        }
                    }
 
                    // If no handle of the active shape was selected check to see if the
                    // body of the active shape was selected
                    if (!activeHandle)
                    {
                        if(selectRectangle(activeShape, xSelectAbs, ySelectAbs))
                        {
                            moveShape   = true;
                        }
                    }
                }
                else if (activeShape.type == "circle")
                {
                    // check to see if a handle has been selected
                    // AR: change for to 'while'
                    for(let i = 0; i < handles.length; i++)
                    {
                        distance = Math.sqrt(Math.pow((xSelectAbs - handles[i].x), 2) + 
                                             Math.pow((ySelectAbs - handles[i].y), 2)); 

                        // Determine if one of the handles has been selected
                        if (distance <= handles[i].radius)
                        {
                            // AR: Change if to switch
                            // Determine which handle has been selected
                            if (handles[i].location == "top")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "right")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "bottom")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }
                            else if (handles[i].location == "left")
                            {
                                activeHandle = handles[i];
                                resizeShape = true;
                            }

                            // set the election point to the center of the handle
                            xSelectSaveAbs = activeHandle.x;
                            ySelectSaveAbs = activeHandle.y;
                        }
                    }
                    // If no handle of the active shape was selected check to see if the
                    // body of the active shape was selected
                    if (!activeHandle)
                    {
                        if(selectCircle(activeShape, xSelectAbs, ySelectAbs))
                        {
                            moveShape = true;
                            xSelectSaveAbs  = xSelectAbs;
                            ySelectSaveAbs  = ySelectAbs;
                        }
                    }
                }
                else if (activeShape.type == "polygon")
                {
                    // check to see if a handle has been selected
                    // AR: change for to 'while'
                    for(let i = 0; i < handles.length; i++)
                    {
                        // Determine if one of the handles has been selected
                        let distance = Math.sqrt(Math.pow((xSelectAbs - handles[i].x), 2) + 
                                                 Math.pow((ySelectAbs - handles[i].y), 2))
                        if (distance <= handles[i].radius)
                        {
                            activeHandle = handles[i];

                            // set the election point to the center of the handle
                            xSelectSaveAbs = activeHandle.x;
                            ySelectSaveAbs = activeHandle.y;

                            resizeShape = true;

                            console.log("DEBUG: A polygon handle has been selected:", activeHandle.location);
                        }
                    }
                    // If no handle of the active shape was selected check to see if the
                    // body of the active shape was selected
                    if (!activeHandle)
                    {
                        // Check to see if the selection point is within the polygon
                        if (selectPolygon(activeShape, xSelectAbs, ySelectAbs)) 
                        {
                            moveShape = true;
                            xSelectSaveAbs  = xSelectAbs;
                            ySelectSaveAbs  = ySelectAbs;

                            console.log("DEBUG: A polygon has been selected:", activeShape);
                        }
                    }
                }
            }

            // Begin panning
            else if (action == 'pan')
            {
                panning = true;
                xSelectSaveAbs = xSelectAbs;
                ySelectSaveAbs = ySelectAbs;
            } 

            // Draw the entire screen
            drawScreen();
        });

        //************************************************************//
        // mouse move events - dependent on selected action and shape
        //************************************************************//
        canvas.addEventListener("mousemove", (e) => 
        {
            // Return if we are not in a mouse down/move/up mode
            if (!createShape && !resizeShape && !rotateShape && !moveShape && !panning)
            {
                return;
            } 

            console.log("DEBUG: *** Mouse move event registered ***");

            // get current mouse location (relative to viewport)
            xMouse = e.clientX - canvas.offsetLeft;
            yMouse = e.clientY - canvas.offsetTop;

            // get current mouse location (absolute)
            xMouseAbs = (e.clientX - canvas.offsetLeft - viewportTransform.x) / viewportTransform.scale;
            yMouseAbs = (e.clientY - canvas.offsetTop  - viewportTransform.y) / viewportTransform.scale;

            // determine how much mouse has moved
            // initial xSelectSaveAbs & ySelectSaveAbs were set via mousedown event
            xDelta = Math.round(xMouseAbs - xSelectSaveAbs);
            yDelta = Math.round(yMouseAbs - ySelectSaveAbs);

            // Draw the active shape
            if (action == "draw")
            { 
                if (shapeOption == "line")
                {
                    activeShape.xEnd += xDelta;
                    activeShape.yEnd += yDelta;
                }
                else if (shapeOption == "rectangle")
                {
                    activeShape.width  += xDelta;
                    activeShape.height += yDelta;
                }
                else if (shapeOption == "circle")
                {
                    xDeltaAcc += xDelta;
                    yDeltaAcc += yDelta;
                    activeShape.radius = Math.sqrt(Math.pow(xDeltaAcc, 2) + Math.pow(yDeltaAcc, 2));
                }
                else if (shapeOption == "polygon")
                {
                    xPolygonVertex += xDelta;
                    yPolygonVertex += yDelta;
                    activeShape.vertices[activeShape.vertices.length - 1] = { x : xPolygonVertex, y : yPolygonVertex };
                }

                // capture the current mouse location
                xSelectSaveAbs += xDelta;
                ySelectSaveAbs += yDelta;
            }
        
            // Move the selected shape
            if(action == 'select' && moveShape && activeShape.type == "line")
            {
                console.log("DEBUG: moving the line");
                // move the shape
                activeShape.xStart += xDelta;
                activeShape.yStart += yDelta;
                activeShape.xEnd   += xDelta;
                activeShape.yEnd   += yDelta;
                // move the handles
                for(let i = 0; i < handles.length; i++)
                {
                    handles[i].x += xDelta;
                    handles[i].y += yDelta;
                }
                // capture the current mouse location
                xSelectSaveAbs += xDelta;
                ySelectSaveAbs += yDelta;
            }
            else if (action == 'select' && moveShape && activeShape.type == "rectangle")
            {
                activeShape.x += xDelta;
                activeShape.y += yDelta;

                for(let i = 0; i < handles.length; i++)
                {
                    handles[i].x += xDelta;
                    handles[i].y += yDelta;
                }
                // capture the current mouse location
                xSelectSaveAbs += xDelta;
                ySelectSaveAbs += yDelta;
            }
            else if (action == 'select' && moveShape && activeShape.type == "circle")
            {
                activeShape.x += xDelta;
                activeShape.y += yDelta;

                for(let i = 0; i < handles.length; i++)
                {
                    handles[i].x += xDelta;
                    handles[i].y += yDelta;
                }
                // capture the current mouse location
                xSelectSaveAbs += xDelta;
                ySelectSaveAbs += yDelta;
            }
            else if (action == 'select' && moveShape && activeShape.type == "polygon")
            {
                console.log("DEBUG: moving the polygon");
                // move the shape
                for(let i = 0; i < activeShape.vertices.length; i++)
                {
                    activeShape.vertices[i].x += xDelta;
                    activeShape.vertices[i].y += yDelta;
                }
                // move the handles
                for(let i = 0; i < handles.length; i++)
                {
                    handles[i].x += xDelta;
                    handles[i].y += yDelta;
                }
                // capture the current mouse location
                xSelectSaveAbs += xDelta;
                ySelectSaveAbs += yDelta;
            }
            
            // Resize the selected shape
            if (action == 'select' && resizeShape && activeShape.type == "line")
            {
                if (activeHandle.location == "start")
                {
                    activeShape.xStart += xDelta;
                    activeShape.yStart += yDelta;

                    handles[0].x += xDelta;
                    handles[0].y += yDelta;
                }
                else if (activeHandle.location == "end")
                {
                    activeShape.xEnd += xDelta;
                    activeShape.yEnd += yDelta;

                    handles[1].x += xDelta;
                    handles[1].y += yDelta;
                }
                // capture the current mouse location
                xSelectSaveAbs += xDelta;
                ySelectSaveAbs += yDelta;
            }
            else if (action == 'select' && resizeShape && activeShape.type == "rectangle")
            {
                // check to see if the selected shape (via mouseclick) has been rotated
                if(activeShape.type == "rectangle" && activeShape.rotation != 0)
                {
                    // rotate the selection coordinates wrt activeShape before checking if 
                    // handle has been selected
                    xShapeCenter = activeShape.x + activeShape.width  / 2;
                    yShapeCenter = activeShape.y + activeShape.height / 2;
                    theta   = activeShape.rotation * -1;

                    xTransAbs = Math.trunc(xShapeCenter + 
                                          (xMouse - xShapeCenter) * Math.cos(theta) - 
                                          (yMouse - yShapeCenter) * Math.sin(theta))
                    yTransAbs = Math.trunc(yShapeCenter + 
                                          (xMouse - xShapeCenter) * Math.sin(theta) + 
                                          (yMouse - yShapeCenter) * Math.cos(theta))

                    xMouse = xTransAbs;
                    yMouse = yTransAbs;
                }

                // modify the rectangle based upon the selected handle + mouse movement
                if (activeHandle.location == "top-left")
                {
                    activeShape.x      += xDelta;
                    activeShape.width  -= xDelta;
                    activeShape.y      += yDelta;
                    activeShape.height -= yDelta;

                    handles[5].x   += xDelta / 2;
                    handles[6].x   += xDelta;
                    handles[7].x   += xDelta;
                    handles[7].y   += yDelta / 2;
                    activeHandle.x += xDelta;
                    activeHandle.y += yDelta;
                    handles[1].x   += xDelta / 2;
                    handles[1].y   += yDelta;
                    handles[2].y   += yDelta;
                    handles[3].y   += yDelta / 2;
                    handles[8].x   += xDelta / 2;
                    handles[8].y   += yDelta;
                }
                else if (activeHandle.location == "top-middle")
                {
                    activeShape.y      += yDelta;
                    activeShape.height -= yDelta;

                    handles[7].y   += yDelta / 2;
                    handles[0].y   += yDelta;
                    activeHandle.y += yDelta;
                    handles[2].y   += yDelta;
                    handles[3].y   += yDelta / 2;
                    handles[8].y   += yDelta;
                }
                else if (activeHandle.location == "top-right")
                {
                    activeShape.width  += xDelta;
                    activeShape.y      += yDelta;
                    activeShape.height -= yDelta;

                    handles[7].y   += yDelta / 2;
                    handles[0].y   += yDelta;
                    handles[1].x   += xDelta / 2;
                    handles[1].y   += yDelta;
                    activeHandle.x += xDelta;
                    activeHandle.y += yDelta;
                    handles[3].x   += xDelta;
                    handles[3].y   += yDelta / 2;
                    handles[4].x   += xDelta;
                    handles[5].x   += xDelta / 2;
                    handles[8].x   += xDelta / 2;
                    handles[8].y   += yDelta;
                }
                else if (activeHandle.location == "right-middle")
                {                 
                    activeShape.width += xDelta;

                    handles[1].x   += xDelta / 2;
                    handles[2].x   += xDelta;
                    activeHandle.x += xDelta;
                    handles[4].x   += xDelta;
                    handles[5].x   += xDelta / 2;
                    handles[8].x   += xDelta / 2;
                }
                else if (activeHandle.location == "bottom-right")
                {
                    activeShape.width  += xDelta;
                    activeShape.height += yDelta;

                    handles[1].x   += xDelta / 2;
                    handles[2].x   += xDelta;
                    handles[3].x   += xDelta;
                    handles[3].y   += yDelta / 2;
                    activeHandle.x += xDelta;
                    activeHandle.y += yDelta;
                    handles[5].x   += xDelta / 2;
                    handles[5].y   += yDelta;
                    handles[6].y   += yDelta;
                    handles[7].y   += yDelta / 2;
                    handles[8].x   += xDelta / 2;
                }
                else if (activeHandle.location == "bottom-middle")
                {
                    activeShape.height += yDelta;

                    handles[3].y   += yDelta / 2;
                    handles[4].y   += yDelta;
                    activeHandle.y += yDelta;
                    handles[6].y   += yDelta;
                    handles[7].y   += yDelta / 2;
                }
                else if (activeHandle.location == "bottom-left")
                {
                    activeShape.x      += xDelta;
                    activeShape.width  -= xDelta;
                    activeShape.height += yDelta;

                    handles[3].y   += yDelta / 2;
                    handles[4].y   += yDelta;
                    handles[5].x   += xDelta / 2;
                    handles[5].y   += yDelta;
                    activeHandle.x += xDelta;
                    activeHandle.y += yDelta;
                    handles[7].x   += xDelta;
                    handles[7].y   += yDelta / 2;
                    handles[0].x   += xDelta;
                    handles[1].x   += xDelta / 2;
                    handles[8].x   += xDelta / 2;
                }
                else if (activeHandle.location == "left-middle")
                {
                    activeShape.x      += xDelta;
                    activeShape.width  -= xDelta;

                    handles[5].x       += xDelta / 2;
                    handles[6].x       += xDelta;
                    activeHandle.x     += xDelta;
                    handles[0].x       += xDelta;
                    handles[1].x       += xDelta / 2;
                    handles[8].x       += xDelta / 2;
                }
                // capture the current mouse location
                xSelectSaveAbs += xDelta;
                ySelectSaveAbs += yDelta;
            }
            else if (action == 'select' && resizeShape && activeShape.type == "circle")
            {
                if (activeHandle.location == "top")
                {
                    activeShape.radius -= yDelta;

                    handles[0].y += yDelta;
                    handles[1].x -= yDelta;
                    handles[2].y -= yDelta;
                    handles[3].x += yDelta;
                }
                else if (activeHandle.location == "right")
                {
                    activeShape.radius += xDelta;

                    handles[0].y -= xDelta;
                    handles[1].x += xDelta;
                    handles[2].y += xDelta;
                    handles[3].x -= xDelta;
                }
                else if (activeHandle.location == "bottom")
                {
                    activeShape.radius += yDelta;

                    handles[0].y -= yDelta;
                    handles[1].x += yDelta;
                    handles[2].y += yDelta;
                    handles[3].x -= yDelta;
                }
                else if (activeHandle.location == "left")
                {
                    activeShape.radius -= xDelta;

                    handles[0].y += xDelta;
                    handles[1].x -= xDelta;
                    handles[2].y -= xDelta;
                    handles[3].x += xDelta;
                }
                // capture the current mouse location
                xSelectSaveAbs += xDelta;
                ySelectSaveAbs += yDelta;
            }
            else if (action == 'select' && resizeShape && activeShape.type == "polygon")
            {
                for(let i = 0; i < activeShape.vertices.length; i++)
                {
                    if (activeHandle.location == "v" + i)
                    {
                        activeShape.vertices[i].x += xDelta;
                        activeShape.vertices[i].y += yDelta;

                        handles[i].x += xDelta;
                        handles[i].y += yDelta;

                        // capture the current mouse location
                        xSelectSaveAbs += xDelta;
                        ySelectSaveAbs += yDelta;
                    }
                }
            }

            // Rotate the selected shape
            if (action == 'select' && rotateShape && activeShape.type == "rectangle")
            {
                // set theta to the current  shape rotation angle
                theta = activeShape.rotation;

                // Determine the amount to rotate the shape based on the mouse movement
                // AR: Find better approach to control the rotation
                theta += (xDelta + yDelta) * 0.01;
                // theta = Math.atan2(yMouse - yShapeCenter, xMouse - xShapeCenter);
                // theta = 45 * (Math.PI / 180);

                activeShape.rotation = theta;

                // Set the rotatation angle for all handles associated with the shape
                for(let i = 0; i < handles.length; i++)
                {
                    handles[i].rotation = theta;
                }
                // capture the current mouse location
                xSelectSaveAbs += xDelta;
                ySelectSaveAbs += yDelta;
            }

            // Pan
            else if (panning)
            {
                // console.log("DEBUG: viewportTransform.x =", viewportTransform.x);
                // console.log("DEBUG: viewportTransform.y =", viewportTransform.y);

                viewportTransform.x += xDelta / viewportTransform.scale;
                viewportTransform.y += yDelta / viewportTransform.scale;
            }

            // Update the shape attributes
            if (action == 'draw' || action == 'select')
            {
                shapeAttributes.innerHTML = displayAttributes(activeShape);
            }

            // Draw the entire screen
            drawScreen();
        });

        //************************************************************//
        // mouse up events - dependent on selected action and shape
        //************************************************************//
        canvas.addEventListener("mouseup", (e) => 
        {
            // Return if we are not in a mouse down/move/up mode
            if (!createShape && !resizeShape && !rotateShape && !moveShape && !panning)
            {
                return;
            } 

            console.log("DEBUG: *** Mouse up event registered ***");
            
            if (action == "draw")
            {
                if (shapeOption == "line")
                {
                    activeShape.label = prompt("Shape label:");
                    shapes.push(activeShape);
                    activeShape = null;
                }
                else if (shapeOption == "rectangle" && activeShape.width > 0 && activeShape.height > 0)
                {
                    activeShape.label = prompt("Shape label:");
                    shapes.push(activeShape);
                    activeShape = null;
                }
                else if (shapeOption == "circle" && activeShape.radius > 0)
                {
                    activeShape.label = prompt("Shape label:");
                    shapes.push(activeShape);
                    activeShape = null;
                }
                else if (shapeOption == "polygon")
                {
                    // Determine if the polygon is being closed
                    const xPolygonStart = activeShape.vertices[0].x;
                    const yPolygonStart = activeShape.vertices[0].y;
                    const xPolygonDistance = Math.abs(xPolygonStart - xMouseAbs);
                    const yPolygonDistance = Math.abs(yPolygonStart - yMouseAbs);

                    if (xPolygonDistance < 8 && yPolygonDistance < 8)
                    {
                        ctx.closePath();
                        activeShape.status = "closed";
                        // since the polygon has been closed remove the last point
                        activeShape.vertices.pop();
                        activeShape.label = prompt("Shape label:");
                        shapes.push(activeShape);
                        polygonWIP = false;
                        activeShape = null;
                    }
                }
            }
            // Draw the entire screen
            drawScreen();

            // reset the current shape and flags
            createShape = false;
            resizeShape = false;
            rotateShape = false;
            moveShape   = false;
            selectShape = false;
            panning     = false;
            xDeltaAcc   = 0;
            yDeltaAcc   = 0;
        });

        //************************************************************//
        // mouse out events - dependent on selected action and shape
        //************************************************************//
        canvas.addEventListener("mouseout", (e) => 
        {
            // Return if we are not in a mouse down/move/up mode
            if (!createShape && !resizeShape && !rotateShape && !moveShape && !panning)
            {
                return;
            } 

            // console.log("DEBUG: ==============================");
            // console.log("DEBUG: Mouse out event registered");
            // console.log("DEBUG: ==============================");

            // reset the current shape and flags
            activeShape = null;
            createShape = false;
            resizeShape = false;
            rotateShape = false;
            moveShape   = false;
            selectShape = false;
            panning     = false;

            // Draw the entire screen
            drawScreen();
        });

        //************************************************************//
        // mouse right click (context menu) events
        //************************************************************//
        // Context menu: Open the  context menu
        canvas.addEventListener("contextmenu", (e) => 
        {
            console.log("DEBUG: *** Mouse right click event registered ***");

            // Prevent default browser context menu
            e.preventDefault()

            // Get mouse position - relative to canvas
            xSelect = e.clientX - canvas.offsetLeft;
            ySelect = e.clientY - canvas.offsetTop;

            // Get mouse position - absolute position
            xSelectAbs = (e.clientX - canvas.offsetLeft - viewportTransform.x) / viewportTransform.scale ;
            ySelectAbs = (e.clientY - canvas.offsetTop  - viewportTransform.y) / viewportTransform.scale ;

            xSelectSaveAbs = xSelectAbs;
            ySelectSaveAbs = ySelectAbs;
            selectPlantCtx = false;
            selectShapeCtx = false;

            // Check to see if a plant or shape has been selected
            for (let i = 0; i < shapes.length; i++) 
            {
                if (shapes[i].isPlant == true)
                {
                    // Check to see if the selection point is within the plant
                    if(selectCircle(shapes[i], xSelectAbs, ySelectAbs))
                    {
                        selectPlantCtx = true;
                        shapeIndex = i;
                        console.log("DEBUG: Plant has been right-clicked!");
                    }
                }
                else if (!shapes[i].isPlant && shapes[i].type == "line")
                {
                    // Determine in the selection point is close to the line
                    // If so, duplicate the line object
                    if(selectLine(shapes[i], xSelectAbs, ySelectAbs))
                    {
                        selectShapeCtx = true;
                        shapeIndex = i;
                    }
                }
                else if (!shapes[i].isPlant && shapes[i].type == 'rectangle')
                {
                    // translate mouse click coordinates if shape is rotated
                    //   ð›¼+(ð‘¥âˆ’ð›¼)cosðœƒâˆ’(ð‘¦âˆ’ð›½)sinðœƒ
                    //   ð›½+(ð‘¥âˆ’ð›¼)sinðœƒ+(ð‘¦âˆ’ð›½)cosðœƒ
                    if(shapes[i].rotation != 0)
                    {
                        xShapeCenter = shapes[i].x + shapes[i].width  / 2;
                        yShapeCenter = shapes[i].y + shapes[i].height / 2;
                        theta   = shapes[i].rotation * -1;

                        xTransAbs = Math.trunc(xShapeCenter + 
                                              (xSelectAbs - xShapeCenter) * Math.cos(theta) - 
                                              (ySelectAbs - yShapeCenter) * Math.sin(theta))
                        yTransAbs = Math.trunc(yShapeCenter + 
                                              (xSelectAbs - xShapeCenter) * Math.sin(theta) + 
                                              (ySelectAbs - yShapeCenter) * Math.cos(theta))
                            
                        xSelectAbs = xTransAbs;
                        ySelectAbs = yTransAbs;
                    }
                    // Determine if the selection point is contained within the rectangle
                    // If so, place resize handles on object
                    if(selectRectangle(shapes[i], xSelectAbs, ySelectAbs))
                    {
                        selectShapeCtx = true;
                        shapeIndex = i;
                    }
                    // Reset the selection point
                    xSelectAbs = xSelectSaveAbs;
                    ySelectAbs = ySelectSaveAbs;
                }               
                else if (!shapes[i].isPlant && shapes[i].type == "circle")
                {
                    if(selectCircle(shapes[i], xSelectAbs, ySelectAbs))
                    {
                        selectShapeCtx = true;
                        shapeIndex = i;
                    }
                }
                else if (!shapes[i].isPlant && shapes[i].type == "polygon")
                {
                    // Check to see if the selection point is within the polygon
                    if(selectPolygon(shapes[i], xSelectAbs, ySelectAbs))
                    {
                        selectShapeCtx = true;
                        shapeIndex = i;
                    }
                }
            }

            // Position and show the custom menu
            if(selectPlantCtx)
            {
                ctxPlantMenu.style.left = xSelect + 'px';
                ctxPlantMenu.style.top  = (ySelect + 140) + 'px';
                ctxPlantMenu.style.display = 'block';
                ctxShapeMenu.style.display = 'none';
            }
            else if (selectShapeCtx)
            {
                ctxShapeMenu.style.left = xSelect + 'px';
                ctxShapeMenu.style.top  = (ySelect + 140) + 'px';
                ctxShapeMenu.style.display = 'block';
                ctxPlantMenu.style.display = 'none';
            }
        });

        // Context menu: Hide when clicking outside of it
        document.addEventListener('click', function(e) 
        {
            if (!ctxPlantMenu.contains(e.target) && !ctxShapeMenu.contains(e.target))
            {
                ctxPlantMenu.style.display = 'none';
                ctxShapeMenu.style.display = 'none';
                // cleanup
                selectPlantCtx = false;
                selectShapeCtx = false;
            }
        });

        // Context menu: Add click handlers for plant menu items
        ctxPlantMenu.addEventListener('click', function(e) 
        {
            if (selectPlantCtx == true && e.target.tagName === 'DIV') 
            {
                if (e.target.textContent == "Plant: Show Details")
                {
                    console.log("DEBUG: Got to context menu - show plant details");

                    // Setup fetch parameters
                    let url             = "{% url 'plants:plant_details_modal' %}"
                    const requestMethod = "POST"
                    const csrfToken     = document.querySelector('[name=csrfmiddlewaretoken]').value;
                    const postData      = { requestedPlant : shapes[shapeIndex].commonName }
                    const plant_details_modal = document.getElementById('plant_details_modal');

                    // Fetch the plant details modal
                    fetch(url, 
                    {
                        method: requestMethod,
                        headers:
                        {
                            // Tells the server that the request body is in JSON format
                            'Content-Type': 'application/json',
                            //  Provides CSRF protection, necessary for Django
                            'X-CSRFToken' : csrfToken
                        },
                        // Convert the dictionary to a JSON string
                        body: JSON.stringify(postData),
                    })
                    .then(response => response.text())
                    .then(html => { plant_details_modal.innerHTML = html; })
                    // enable the model display
                    plant_details_modal.style.display = 'block'
                }
                else if (e.target.textContent == "Plant: Duplicate")
                {
                    // console.log("DEBUG: Duplicate Shape");
                    // make a deep copy of selected shape and shift new object origin to make it visible
                    // const newShape = {};
                    // Object.assign(newShape, shapes[shapeIndex]);
                    const newShape = JSON.parse(JSON.stringify(shapes[shapeIndex]));
                    newShape.x += 20;
                    newShape.y += 20;
                    shapes.push(newShape);
                }
                else if (e.target.textContent == "Plant: Delete")
                {
                    // console.log("DEBUG: Delete Shape - shapeIndex = ", shapeIndex);
                    shapes.splice(shapeIndex, 1);
                }
                // Hide menu after action
                ctxPlantMenu.style.display = 'none'; 
            }
            // cleanup
            selectShapeCtx = false;
            handles = [];
            // Draw the entire screen
            drawScreen();
        });

        // Context menu: Add click handlers for shape menu items
        ctxShapeMenu.addEventListener('click', function(e) 
        {
            if (selectShapeCtx == true && e.target.tagName === 'DIV') 
            {
                if (e.target.textContent == "Shape: Edit")
                {
                    // display the shape edit model
                    planner_edit_modal.style.display = 'block';
                    // turn off display for all fields - required fields turned back on late
                    // AR: Change to a more efficient selector
                    for (let i = 0; i < line.length; i++) 
                    {
                        line[i].style.display = "none";
                    }
                    for (let i = 0; i < rectangle.length; i++) 
                    {
                        rectangle[i].style.display = "none";
                    }
                    for (let i = 0; i < circle.length; i++) 
                    {
                        circle[i].style.display = "none";
                    }
                    for (let i = 0; i < polygon.length; i++) 
                    {
                        polygon[i].style.display = "none";
                    }
                    //
                    if (shapes[shapeIndex].type == "line")
                    {
                        // turn on the display for all edit form fields used by line
                        for (let i = 0; i < line.length; i++) 
                        {
                            line[i].style.display = "inline";
                        }
                        // prepopulate the shape attribute fields - convert pixels to ft/in
                        labelForm.value     = shapes[shapeIndex].label;
                        xStartFtForm.value  = Math.trunc(shapes[shapeIndex].xStart / 12) - (extBorder / 12);
                        xStartInForm.value  = shapes[shapeIndex].xStart % 12;
                        yStartFtForm.value  = Math.trunc(shapes[shapeIndex].yStart / 12) - (extBorder / 12);
                        yStartInForm.value  = shapes[shapeIndex].yStart % 12;
                        xEndFtForm.value    = Math.trunc(shapes[shapeIndex].xEnd / 12) - (extBorder / 12);
                        xEndInForm.value    = shapes[shapeIndex].xEnd % 12;
                        yEndFtForm.value    = Math.trunc(shapes[shapeIndex].yEnd / 12) - (extBorder / 12);
                        yEndInForm.value    = shapes[shapeIndex].yEnd % 12;
                        lineWidthForm.value = shapes[shapeIndex].lineWidth;
                        lineStyleForm.value = shapes[shapeIndex].lineStyle;
                        lineColorForm.value = shapes[shapeIndex].lineColor;
                    }
                    else if (shapes[shapeIndex].type == "rectangle")
                    {
                        // turn on the display for all edit form fields used by rectangle
                        for (let i = 0; i < rectangle.length; i++) 
                        {
                            rectangle[i].style.display = "inline";
                        }
                        // prepopulate the shape attribute fields
                        // - convert pixels to ft/in
                        // - convert radians to degrees
                        labelForm.value     = shapes[shapeIndex].label;
                        xFtForm.value       = Math.trunc(shapes[shapeIndex].x / 12) - (extBorder / 12);
                        xInForm.value       = shapes[shapeIndex].x % 12;
                        yFtForm.value       = Math.trunc(shapes[shapeIndex].y / 12) - (extBorder / 12);
                        yInForm.value       = shapes[shapeIndex].y % 12;
                        widthFtForm.value   = Math.trunc(shapes[shapeIndex].width / 12);
                        widthInForm.value   = shapes[shapeIndex].width % 12;
                        heightFtForm.value  = Math.trunc(shapes[shapeIndex].height / 12);
                        heightInForm.value  = shapes[shapeIndex].height % 12;
                        rotationForm.value  = shapes[shapeIndex].rotation * (180 / Math.PI);
                        lineWidthForm.value = shapes[shapeIndex].lineWidth;
                        lineStyleForm.value = shapes[shapeIndex].lineStyle;
                        lineColorForm.value = shapes[shapeIndex].lineColor;
                        fillColorForm.value = shapes[shapeIndex].fillColor;
                    }
                    else if (shapes[shapeIndex].type == "circle")
                    {
                        // turn on the display for all edit form fields used by circle
                        for (let i = 0; i < circle.length; i++) 
                        {
                            circle[i].style.display = "inline";
                        }
                        // prepopulate the shape attribute fields - convert pixels to ft/in
                        labelForm.value     = shapes[shapeIndex].label;
                        xCenterFtForm.value = Math.trunc(shapes[shapeIndex].x / 12) - (extBorder / 12);
                        xCenterInForm.value = shapes[shapeIndex].x % 12;
                        yCenterFtForm.value = Math.trunc(shapes[shapeIndex].y / 12) - (extBorder / 12);
                        yCenterInForm.value = shapes[shapeIndex].y % 12;
                        radiusFtForm.value  = Math.trunc(shapes[shapeIndex].radius / 12);
                        radiusInForm.value  = Math.round(shapes[shapeIndex].radius % 12);
                        lineWidthForm.value = shapes[shapeIndex].lineWidth;
                        lineStyleForm.value = shapes[shapeIndex].lineStyle;
                        lineColorForm.value = shapes[shapeIndex].lineColor; 
                        fillColorForm.value = shapes[shapeIndex].fillColor;        
                    }
                    else if (shapes[shapeIndex].type == "polygon")
                    {
                        // turn on the display for all edit form fields used by polygon
                        for (let i = 0; i < polygon.length; i++) 
                        {
                            polygon[i].style.display = "inline";
                        }

                        // Go through all vertices and construct html input form elements
                        let polyHTML = '';
                        for (let i = 0; i < shapes[shapeIndex].vertices.length; i++) 
                        {
                            polyHTML += '<label for="xV' + i + 'Ft" style="display: inline-block; width: 80px;">v' + i + ' x: </label>\n' +
                                    '<input type="number" class="xVFt" name="xV"' + i + '"Ft" style="width: 50px;">\n' +
                                    '<span>ft</span>\n' +
                                    '<input type="number" class="xVIn" name="xV"' + i + '"In" style="width: 50px;">\n' +
                                    '<span>in</span>\n' +
                                    '<br>\n' +
                                    '<label for="yV' + i + 'Ft" style="display: inline-block; width: 80px;">v' + i + ' y: </label>\n' +
                                    '<input type="number" class="yVFt" name="yV"' + i + '"Ft" style="width: 50px;">\n' +
                                    '<span>ft</span>\n' +
                                    '<input type="number" class="yVIn" name="yV"' + i + '"In" style="width: 50px;">\n' +
                                    '<span>in</span>\n' +
                                    '<br>\n'
                        }
                        polygonHTML.innerHTML = polyHTML;

                        const xVFt = document.getElementsByClassName('xVFt');
                        const xVIn = document.getElementsByClassName('xVIn');
                        const yVFt = document.getElementsByClassName('yVFt');
                        const yVIn = document.getElementsByClassName('yVIn');

                        // prepopulate the shape attribute fields - convert pixels to ft/in
                        labelForm.value     = shapes[shapeIndex].label;
                        // walk through each vertex, convert pixels to ft/in, and set form field
                        for (let i = 0; i < xVFt.length; i++) 
                        {
                            xVFt[i].value = Math.trunc(shapes[shapeIndex].vertices[i].x / 12) - (extBorder / 12);
                            xVIn[i].value = shapes[shapeIndex].vertices[i].x % 12;
                            yVFt[i].value = Math.trunc(shapes[shapeIndex].vertices[i].y / 12) - (extBorder / 12);
                            yVIn[i].value = shapes[shapeIndex].vertices[i].y % 12;
                        }

                        lineWidthForm.value = shapes[shapeIndex].lineWidth;
                        lineStyleForm.value = shapes[shapeIndex].lineStyle;
                        lineColorForm.value = shapes[shapeIndex].lineColor;
                        fillColorForm.value = shapes[shapeIndex].fillColor;
                    }
                }
                else if (e.target.textContent == "Shape: Duplicate")
                {
                    // console.log("DEBUG: Duplicate Shape");
                    // make a deep copy of selected shape and shift new object origin to make it visible
                    // const newShape = {};
                    // Object.assign(newShape, shapes[shapeIndex]);
                    const newShape = JSON.parse(JSON.stringify(shapes[shapeIndex]));
                    if(shapes[shapeIndex].type == "line")
                    {
                        newShape.xStart += 20;
                        newShape.yStart += 20;
                        newShape.xEnd   += 20;
                        newShape.yEnd   += 20;
                    }
                    else if(shapes[shapeIndex].type == "rectangle")
                    {
                        newShape.x += 20;
                        newShape.y += 20;
                    }
                    else if(shapes[shapeIndex].type == "circle")
                    {
                        newShape.x += 20;
                        newShape.y += 20;
                    }
                    else if(shapes[shapeIndex].type == "polygon")
                    {
                        for (let i = 0; i < newShape.vertices.length; i++)
                        {
                            newShape.vertices[i].x += 20;
                            newShape.vertices[i].y += 20;
                        }
                    }
                    shapes.push(newShape);
                }
                else if (e.target.textContent == "Shape: Delete")
                {
                    // console.log("DEBUG: Delete Shape - shapeIndex = ", shapeIndex);
                    shapes.splice(shapeIndex, 1);
                }
                
                // Hide menu after action
                ctxShapeMenu.style.display = 'none'; 
            }
            // cleanup
            selectShapeCtx = false;
            handles = [];
            // Draw the entire screen
            drawScreen();
        });

        // function to process the user's inputs from the attribute edit form
        const editForm = document.getElementById('id_edit_form');
        editForm.addEventListener('submit', function(e)
        {
            // This line prevents the default form submission (page reload)
            e.preventDefault(); 

            console.log("DEBUG: Got to processEditForm");
            console.log("DEBUG: shapes[shapeIndex] (before) = ", shapes[shapeIndex]);

            if (shapes[shapeIndex].type == "line")
            {
                // update the selected shape with the new attribute values - convert ft/in to pixels
                shapes[shapeIndex].label     = labelForm.value;
                shapes[shapeIndex].xStart    = (Number(xStartFtForm.value) * 12) + 
                                               (Number(xStartInForm.value) % 12) +
                                               extBorder;
                shapes[shapeIndex].yStart    = (Number(yStartFtForm.value) * 12) + 
                                               (Number(yStartInForm.value) % 12) +
                                               extBorder;
                shapes[shapeIndex].lineWidth = Number(lineWidthForm.value);
                shapes[shapeIndex].lineStyle = lineStyleForm.value;
                shapes[shapeIndex].lineColor = lineColorForm.value;
            }
            else if (shapes[shapeIndex].type == "rectangle")
            {
                // update the selected shape with the new attribute values - convert ft/in to pixels
                shapes[shapeIndex].label     = labelForm.value;
                shapes[shapeIndex].x         = (Number(xFtForm.value) * 12) + 
                                               (Number(xInForm.value) % 12) +
                                               extBorder;
                shapes[shapeIndex].y         = (Number(yFtForm.value) * 12) + 
                                               (Number(yInForm.value) % 12) +
                                               extBorder;
                shapes[shapeIndex].width     = (Number(widthFtForm.value) * 12) + 
                                               (Number(widthInForm.value) % 12);
                shapes[shapeIndex].height    = (Number(heightFtForm.value) * 12) + 
                                               (Number(heightInForm.value) % 12);
                shapes[shapeIndex].rotation  = Number(rotationForm.value) * (Math.PI / 180);
                shapes[shapeIndex].lineWidth = Number(lineWidthForm.value);
                shapes[shapeIndex].lineStyle = lineStyleForm.value;
                shapes[shapeIndex].lineColor = lineColorForm.value;
                shapes[shapeIndex].fillColor = fillColorForm.value;

                console.log("DEBUG: shapes[shapeIndex] (after) = ", shapes[shapeIndex]);

                planner_edit_modal.style.display = 'none';
            }
            else if (shapes[shapeIndex].type == "circle")
            {
                // update the selected shape with the new attribute values - convert ft/in to pixels
                shapes[shapeIndex].label     = labelForm.value;
                shapes[shapeIndex].x         = (Number(xCenterFtForm.value) * 12) + 
                                               (Number(xCenterInForm.value) % 12) +
                                               extBorder;
                shapes[shapeIndex].y         = (Number(yCenterFtForm.value) * 12) + 
                                               (Number(yCenterInForm.value) % 12) +
                                               extBorder;
                shapes[shapeIndex].radius    = (Number(radiusFtForm.value) * 12) + 
                                               (Number(radiusInForm.value) % 12);
                shapes[shapeIndex].lineWidth = Number(lineWidthForm.value);
                shapes[shapeIndex].lineStyle = lineStyleForm.value;
                shapes[shapeIndex].lineColor = lineColorForm.value;
                shapes[shapeIndex].fillColor = fillColorForm.value;

                planner_edit_modal.style.display = 'none';
            }
            else if (shapes[shapeIndex].type == "polygon")
            {
                //
                const xVFt = document.getElementsByClassName('xVFt');
                const xVIn = document.getElementsByClassName('xVIn');
                const yVFt = document.getElementsByClassName('yVFt');
                const yVIn = document.getElementsByClassName('yVIn');

                // update the selected shape with the new attribute values
                shapes[shapeIndex].label     = labelForm.value;
                // walk through vertex, convert ft/in to pixels, and save to selected polygon
                for (let i = 0; i < xVFt.length; i++)
                {
                    shapes[shapeIndex].vertices[i].x = (Number(xVFt[i].value) * 12) + 
                                                       (Number(xVIn[i].value) % 12) +
                                                        extBorder;
                    shapes[shapeIndex].vertices[i].y = (Number(yVFt[i].value) * 12) + 
                                                       (Number(yVIn[i].value) % 12) +
                                                        extBorder;
                }
                shapes[shapeIndex].lineWidth = Number(lineWidthForm.value);
                shapes[shapeIndex].lineStyle = lineStyleForm.value;
                shapes[shapeIndex].lineColor = lineColorForm.value;
                shapes[shapeIndex].fillColor = fillColorForm.value;
                // hide the modal
                planner_edit_modal.style.display = 'none';
            }
            
            // Draw the entire screen
            drawScreen();
        });

        //************************************************************//
        // mouse wheel events - zoom
        //************************************************************//
        canvas.addEventListener("mousewheel", (e) => 
        {
            // Return if we are not in zoom mode
            if (action != "zoom")
            {
                return;
            } 

            console.log("DEBUG: Mouse wheel event registered");

            // Save the previous transforms and scale factor
            const previousScale = viewportTransform.scale;
            const previousX     = viewportTransform.x;
            const previousY     = viewportTransform.y;

            // limit the zoom factors
            const zoomMin = 0.25;
            const zoomMax = 4.00;

            // capture the current mouse location 
            xMouse = e.clientX;
            yMouse = e.clientY;

            const newScale = viewportTransform.scale + (e.deltaY * -0.01);

            if(newScale >= zoomMin && newScale <= zoomMax)
            {
                // set the new scale factor
                viewportTransform.scale = newScale;

                // set the new transformation coordinates in order to ...
                viewportTransform.x = xMouse - (xMouse - previousX) * (newScale / previousScale);
                viewportTransform.y = yMouse - (yMouse - previousY) * (newScale / previousScale);
            }

            // Draw the entire screen
            drawScreen()
        });

        //************************************************************//
        // Function: Display shape attributes
        //************************************************************//
        function displayAttributes(shape)
        {
            if (shape.type == "line")
            {
                let xStart = shape.xStart - extBorder;
                let yStart = shape.yStart - extBorder;
                let xEnd   = shape.xEnd   - extBorder;
                let yEnd   = shape.yEnd   - extBorder;

                let length = Math.round(Math.sqrt(Math.pow((shape.xEnd - shape.xStart), 2) + 
                                                  Math.pow((shape.yEnd - shape.yStart), 2)))
                displayText = "<p>" + shape.label + ": " +
                              "start: (" + pix2ft(xStart) + ", " + pix2ft(yStart) + ") " +
                              "end: ("   + pix2ft(xEnd)   + ", " + pix2ft(yEnd)   + ") " +
                              "length: " + pix2ft(length) +
                              "</p>";
            }
            else if (shape.type == "rectangle")
            {
                xCenter = shape.x + (shape.width  / 2) - extBorder;
                yCenter = shape.y + (shape.height / 2) - extBorder;
                let rotation = shape.rotation * 180 / Math.PI;

                displayText = "<p>" + shape.label + ": " +
                              "center: ("  + pix2ft(xCenter) + ", " + pix2ft(yCenter) + ") " + 
                              "width: "    + pix2ft(shape.width)  + ") " +
                              "height: "   + pix2ft(shape.height) + ") " +
                              "rotation: " + rotation.toFixed(1) + " degrees" +
                              "</p>";
            }
            else if (shape.type == "circle")
            {
                xCenter = shape.x - extBorder;
                yCenter = shape.y - extBorder;

                displayText = "<p>" + shape.label + ": " +
                              "center: (" + pix2ft(xCenter) + ", " + pix2ft(yCenter)+ ") " +
                              "radius: "  + pix2ft(shape.radius) +
                              "</p>";
           }
            else if (shape.type == "polygon")
            {
                let vertices = "";
                for(let i = 0; i < shape.vertices.length; i++)
                {
                    vertices += "v" + i + ": (" + 
                                pix2ft(shape.vertices[0].x - extBorder) + ", " + 
                                pix2ft(shape.vertices[0].y - extBorder) + "), "
                }
                displayText = "<p>" + shape.label + ": " + vertices + "</p>";
            }
            return(displayText);       
        }
   
        //************************************************************//
        // Function: Place handle
        //************************************************************//
        function placeHandle(location, x, y, rotation, shape_id)
        {
            handle = 
            { 
                type       : "handle", 
                x          : x, 
                y          : y, 
                radius     : 5,
                startAngle : 0, 
                endAngle   : 2 * Math.PI,
                direction  : "clockwise",
                lineWidth  : 1,
                lineStyle  : "solid",
                lineColor  : "black",
                color      : "white",
                location   : location,
                rotation   : rotation,
                shape_id   : shape_id
            };
            return(handle);       
        }
   
        //************************************************************//
        // Function: line selection
        //************************************************************//
        function selectLine(shape, x, y)
        {
            // Determine if the selection point is 'close' to the line

            // set the threshold
            const threshold = 3;
                        
            // Calculate the difference in coordinates for the line segment
            const dx = shape.xEnd - shape.xStart;
            const dy = shape.yEnd - shape.yStart;

            // Calculate the squared length of the line segment
            const lineLengthSq = dx * dx + dy * dy;

            // Calculate the parameter 't' for the closest point on the *infinite* line
            // This 't' represents the projection of the point onto the line.
            const t = ((x - shape.xStart) * dx + (y - shape.yStart) * dy) / lineLengthSq;

            // Clamp 't' to the range [0, 1] to ensure the closest point is on the *segment*
            const closestX = shape.xStart + t * dx;
            const closestY = shape.yStart + t * dy;

            // Calculate the distance from the point to the closest point on the segment
            const distance = Math.sqrt(Math.pow(x - closestX, 2) + Math.pow(y - closestY, 2));

            return(distance <= threshold);
        }

        //************************************************************//
        // Function: rectangle selection
        //************************************************************//
        function selectRectangle(shape, x, y)
        {
            return(x >= shape.x && x <= (shape.x + shape.width) && 
                   y >= shape.y && y <= (shape.y + shape.height))
        }

        //************************************************************//
        // Function: circle selection
        //************************************************************//
        function selectCircle(shape, x, y)
        {
            // find the distance of the cursor position from the circle center and compare to the radius
            distance = Math.sqrt(Math.pow((x - shape.x), 2) + Math.pow((y - shape.y), 2))
            return(distance <= shape.radius);
        }

        //************************************************************//
        // Function: polygon selection
        //************************************************************//
        function selectPolygon(shape, x, y)
        {
            // Create the path for the target polygon
            ctx.beginPath();
            ctx.moveTo(shape.vertices[0].x, shape.vertices[0].y);
            for (let j = 1; j < shape.vertices.length; j++) 
            {
                ctx.lineTo(shape.vertices[j].x, shape.vertices[j].y);
            }
            ctx.closePath();
            // return 'true' if the X-Y coordinates are contained within the polygon
            return(ctx.isPointInPath(x, y));
        }

        //************************************************************//
        // Function: pixels to feet
        //************************************************************//
        function pix2ft(pixels)
        {
            return(Math.trunc(pixels / 12)) + " ft  " + Math.trunc(pixels % 12) + " in";
        }

        //************************************************************//
        // Function: Drag-and-Drop
        //************************************************************//
        //Make the modal (<div> element) draggable:
        dragElement(document.getElementById("plant_details_modal"));
        // dragElement(document.getElementById("planner_edit_modal"));
        function dragElement(elmnt) 
        {
            var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            if (document.getElementById(elmnt.id + "header")) 
            {
                /* if present, the header is where you move the DIV from:*/
                document.getElementById(elmnt.id + "header").onmousedown = dragMouseDown;
            } 
            else 
            {
                /* otherwise, move the DIV from anywhere inside the DIV:*/
                elmnt.onmousedown = dragMouseDown;
            }

            function dragMouseDown(e) 
            {
                e = e || window.event;
                e.preventDefault();
                // get the mouse cursor position at startup:
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.onmouseup = closeDragElement;
                // call a function whenever the cursor moves:
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) 
            {
                e = e || window.event;
                e.preventDefault();
                // calculate the new cursor position:
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                // set the element's new position:
                elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
                elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
            }

            function closeDragElement() 
            {
                /* stop moving when mouse button is released:*/
                document.onmouseup = null;
                document.onmousemove = null;
            }
        }

        //************************************************************//
        // Function: Draw shape
        //************************************************************//
        function drawShape(shape) 
        {
            // Set the text label defaults
            ctx.font         = '16px chalkboard';
            ctx.fillStyle    = 'black';
            ctx.textAlign    = 'center';
            ctx.textBaseline = 'middle';

            if (shape.type === "line")
            {
                // setup the drawing parameters
                ctx.lineWidth   = shape.lineWidth;
                if(shape.lineStyle == 'solid')
                {
                    ctx.setLineDash([]);
                }
                else if(shape.lineStyle == 'dashed')
                {
                    ctx.setLineDash([7, 5]);
                }
                else if(shape.lineStyle == 'dotted')
                {
                    ctx.setLineDash([2, 4]);
                }
                ctx.strokeStyle = shape.lineColor;

                // draw the line
                ctx.beginPath();
                ctx.moveTo(shape.xStart, shape.yStart);
                ctx.lineTo(shape.xEnd,   shape.yEnd);
                ctx.stroke();

                // add the label - find the center of the line
                xShapeCenter = (shape.xEnd + shape.xStart) / 2;
                yShapeCenter = (shape.yEnd + shape.yStart) / 2;
                const maxWidth = Math.sqrt((Math.pow((shape.xEnd - shape.xStart), 2)) + 
                                           (Math.pow((shape.yEnd - shape.yStart), 2) )) * 0.8;

                ctx.font         = '16px chalkboard';
                ctx.fillStyle    = 'black';
                ctx.textAlign    = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(shape.label, xShapeCenter, yShapeCenter, maxWidth);
            }
            else if (shape.type === "rectangle") 
            {
                // setup the drawing parameters
                ctx.lineWidth   = shape.lineWidth;
                if(shape.lineStyle == 'solid')
                {
                    ctx.setLineDash([]);
                }
                else if(shape.lineStyle == 'dashed')
                {
                    ctx.setLineDash([5, 5]);
                }
                else if(shape.lineStyle == 'dotted')
                {
                    ctx.setLineDash([2, 4]);
                }
                ctx.strokeStyle = shape.lineColor;
                ctx.fillStyle   = shape.fillColor;

                // find center of rectangle
                xShapeCenter = shape.x + (shape.width  / 2);
                yShapeCenter = shape.y + (shape.height / 2);

                if(shape.rotation == 0)
                {
                    ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
                    ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
                }
                else
                {
                    // ctx.setTransform(1, 0, 0, 1, 0, 0);
                    //
                    ctx.save();
                    // Translate to rectangle center
                    ctx.translate(xShapeCenter, yShapeCenter);
                    // Rotate
                    ctx.rotate(shape.rotation);
                    // Translate back
                    ctx.translate(-xShapeCenter, -yShapeCenter);

                    // Draw the rectangle
                    ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
                    ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
                    //
                    ctx.restore();
                }

                // add the label

                const maxWidth = shape.width * 0.8;

                ctx.font         = '16px chalkboard';
                ctx.fillStyle    = 'black';
                ctx.textAlign    = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(shape.label, xShapeCenter, yShapeCenter, maxWidth);
            }
            else if (shape.type === "rectangle-nofill") 
            {
                // setup the drawing parameters
                ctx.strokeStyle = shape.strokeStyle;
                ctx.lineWidth   = shape.lineWidth;
                ctx.setLineDash([]);

                //
                if(shape.rotation == 0)
                {
                    // Draw the rectangle
                    ctx.strokeRect(shape.x, shape.y, shape.width, shape.height);
                }
                else
                {
                    // find the center of shape
                    xShapeCenter = shape.x + (shape.width  / 2);
                    yShapeCenter = shape.y + (shape.height / 2);
                                    
                    // ctx.setTransform(1, 0, 0, 1, 0, 0);

                    //
                    // ctx.save();
                    // Translate to rectangle center
                    ctx.translate(xShapeCenter, yShapeCenter);
                    // Rotate
                    ctx.rotate(shape.rotation);
                    // Translate back
                    ctx.translate(-xShapeCenter, -yShapeCenter);

                    // Draw the rectangle
                    ctx.fillRect(shape.x, shape.y, shape.width, shape.height);
                    //
                    // ctx.restore();
                }
                // Restore defaults
                ctx.strokeStyle = strokeStyleDefault;
                ctx.lineWidth   = lineWidthDefault;
            }
            else if (shape.type === "circle") 
            {
                // setup the drawing parameters
                ctx.lineWidth   = shape.lineWidth;
                if(shape.lineStyle == 'solid')
                {
                    ctx.setLineDash([]);
                }
                else if(shape.lineStyle == 'dashed')
                {
                    ctx.setLineDash([5, 5]);
                }
                else if(shape.lineStyle == 'dotted')
                {
                    ctx.setLineDash([2, 4]);
                }
                ctx.strokeStyle = shape.lineColor;
                ctx.fillStyle   = shape.fillColor;

                // draw the circle
                ctx.beginPath();
                ctx.arc(shape.x, shape.y, shape.radius, shape.startAngle, shape.endAngle, shape.direction);
                ctx.fillStyle = shape.color;
                ctx.fill();
                ctx.stroke();

                // add the label
                const maxWidth = shape.radius * 2;
                ctx.font         = '16px chalkboard';
                ctx.fillStyle    = 'black';
                ctx.textAlign    = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(shape.label, shape.x, shape.y, maxWidth);
            }
            else if (shape.type === "polygon")
            {
                // setup the drawing parameters
                ctx.lineWidth   = shape.lineWidth;
                if(shape.lineStyle == 'solid')
                {
                    ctx.setLineDash([]);
                }
                else if(shape.lineStyle == 'dashed')
                {
                    ctx.setLineDash([7, 5]);
                }
                else if(shape.lineStyle == 'dotted')
                {
                    ctx.setLineDash([2, 4]);
                }
                ctx.strokeStyle = shape.lineColor;
                ctx.fillStyle   = shape.fillColor;

                // draw the polygon
                ctx.beginPath();
                ctx.moveTo(shape.vertices[0].x, shape.vertices[0].y);

                if(shape.vertices.length > 1)
                {
                    for(let i = 1; i < shape.vertices.length; i++)
                    {
                        ctx.lineTo(shape.vertices[i].x, shape.vertices[i].y);
                    }
                }
                if(shape.status == "closed")
                {
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.stroke();

                // if the polygon drawing is done, add the label
                if (shape.status == "closed")
                {
                    // find center of polygon
                    let sumX = 0;
                    let sumY = 0;
                    for (let i = 0; i < shape.vertices.length; i++) 
                    {
                        sumX += shape.vertices[i].x;
                        sumY += shape.vertices[i].y;
                    }

                    xShapeCenter = sumX / shape.vertices.length;
                    yShapeCenter = sumY / shape.vertices.length;

                    const maxWidth = 100;

                    ctx.font         = '16px chalkboard';
                    ctx.fillStyle    = 'black';
                    ctx.textAlign    = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(shape.label, xShapeCenter, yShapeCenter, maxWidth);
                }
            }
            else if (shape.type === "handle") 
            {
                // setup the drawing parameters
                ctx.lineWidth   = shape.lineWidth;
                ctx.strokeStyle = shape.lineColor;
                ctx.fillStyle   = shape.fillColor;
                ctx.setLineDash([])

                // adjust the handle radius based upon he scale factor
                radiusScaled = shape.radius / viewportTransform.scale;

                // find center of associated shape to determine the point of rotation for handle
                xShapeCenter = shapes[shape.shape_id].x + shapes[shape.shape_id].width  / 2;
                yShapeCenter = shapes[shape.shape_id].y + shapes[shape.shape_id].height / 2;
                //
                ctx.save();
                // Translate to rectangle center
                ctx.translate(xShapeCenter, yShapeCenter);
                // Rotate
                ctx.rotate(shape.rotation);
                // Translate back
                ctx.translate(-xShapeCenter, -yShapeCenter);
                // Draw the handle
                ctx.beginPath();
                ctx.arc(shape.x, shape.y, radiusScaled, shape.startAngle, shape.endAngle, shape.direction);
                ctx.stroke();
                //
                ctx.restore();
            }
        }
     
        //************************************************************//
        // Function: Draw the entire screen
        //************************************************************//
        function drawScreen() 
        {
            //
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            //
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            //
            ctx.save();
            //
            ctx.setTransform(viewportTransform.scale, 0, 0, viewportTransform.scale, viewportTransform.x, viewportTransform.y);
            //
            //
            // Place origin coordinates (0,0) at top-left corner
            ctx.font         = '16px chalkboard';
            ctx.fillStyle    = 'black';
            ctx.textAlign    = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("(0,0)", extBorder - 10, extBorder - 10);

            // Draw the landscape plot border
            // for (let i = 0; i < backgrounds.length; i++) 
            // {
            //     drawShape(backgrounds[i]);
            // }

            ctx.lineWidth   = 2;
            ctx.lineStyle   = "solid";
            ctx.strokeStyle = "green";
            const v0 = {x : extBorder +    0, y : extBorder +    0}
            const v1 = {x : extBorder + 3000, y : extBorder +   30}
            const v2 = {x : extBorder + 3000, y : extBorder + 2000}
            const v3 = {x : extBorder +    0, y : extBorder + 2000}
            const arcV2V3 = {x : extBorder + 1900, y : extBorder + 1900}
            
            ctx.beginPath();
            ctx.moveTo(v0.x, v0.y);
            ctx.lineTo(v1.x, v1.y);
            ctx.lineTo(v2.x, v2.y);
            ctx.quadraticCurveTo(arcV2V3.x, arcV2V3.y, v3.x, v3.y);
            ctx.closePath();
            // ctx.fill();
            ctx.stroke();

            // Draw shapes stored in shapes array
            for (let i = 0; i < shapes.length; i++) 
            {
                drawShape(shapes[i]);
            }
            // Draw the shape that is currently being created/modified
            if (activeShape)
            {
                drawShape(activeShape);
            }
            // Draw handles on the selected shape
            for (let i = 0; i < handles.length; i++) 
            {
                drawShape(handles[i]);         
            }
            //
            ctx.restore();
        }

        //************************************************************//
        // Function: Save the canvas to db
        //************************************************************//
        save = document.getElementById("id_save");
        save.onclick = async (event) => 
        {
            // AR: Is this necessary?
            event.preventDefault();
            // Acquire the CSRF token
            const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
            //  Converts the JavaScript object to a JSON string
            let shapes_JSON = JSON.stringify(shapes);
            // Send the drawing objects back to the Django view
            const postURL = window.location.pathname;
            // Sends the HTTP request
            fetch(postURL, 
            {
               // Specifies the request method
                method: "POST",
                headers: 
                {
                    // Tells the server that the request body is in JSON format
                    'Content-Type': 'application/json',
                    //  Provides CSRF protection, necessary for Django forms
                    'X-CSRFToken' : csrfToken
                },
                // JSON payload
                body: shapes_JSON
            })
            .then(response => response.json())
            .then(result => console.log('POST was a success: ${result}'))
            .catch(error => console.error('An error occurred: ${error}'))
        };

        //************************************************************//
        // Function: Clear the canvas of all shapes
        //************************************************************//
        clear = document.getElementById("id_clear");
        clear.onclick = async (event) => 
        {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            shapes.length = 0;
        };
    }

    //-----------------------------------------------------//
    // Code for drawing freeform lines on canvas via mouse //
    //-----------------------------------------------------//
    // function canvasApp()
    // {
    //     // Flag to track if the user is drawing
    //     let createShape = false; 
    //     // Store the last mouse position
    //     let lastX, lastY; 

    //     canvas.addEventListener('mousedown', startDrawing);
    //     canvas.addEventListener('mousemove', draw);
    //     canvas.addEventListener('mouseup', stopDrawing);
    //     // Stop drawing if mouse leaves the canvas
    //     canvas.addEventListener('mouseout', stopDrawing); 

    //     function startDrawing(event) {
    //         createShape = true;
    //         lastX = event.offsetX;
    //         lastY = event.offsetY;
    //         ctx.beginPath(); // Start a new path
    //         ctx.moveTo(lastX, lastY); // Move to the starting point
    //     }

    //     function draw(event) {
    //         if (!createShape) return; // Don't draw if not drawing
    //         ctx.lineTo(event.offsetX, event.offsetY); // Draw a line to the current position
    //         ctx.stroke(); // Stroke the line
    //         lastX = event.offsetX;
    //         lastY = event.offsetY;
    //     }

    //     function stopDrawing(event) {
    //         createShape = false;
    //     }
    // }

</script>
{% endblock js %}